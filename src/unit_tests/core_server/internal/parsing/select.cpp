#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>

#include "core_server/internal/ceql/query/query.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "core_server/internal/parsing/ceql_query/visitors/select_visitor.hpp"

namespace CORE::Internal::CEQL::UnitTests {

std::string
create_select_query(std::string strategy, std::string variable_names) {
  // clang-format off
  return "SELECT " + strategy + " " + variable_names + "\n"
         "FROM S, S2\n"
         "WHERE ( S>T ; H + ; T AS t2 ) AS all_events\n"
         "--WHERE H+ OR H+\n"
         "FILTER\n"
         "    all_events[id NOT IN { 123, 125 }]\n"
         "    AND\n"
         "    ( t2[temp > 50 or temp < 20] OR H[income > 2 * cost] )\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

Select parse_select(std::string query) {
  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();
  Parsing::SelectVisitor select_visitor;
  select_visitor.visit(tree);
  return select_visitor.get_parsed_select();
}

TEST_CASE("Select captures strategy correctly", "[Select, Strategy]") {
  // clang-format off
  REQUIRE(parse_select(create_select_query("ALL", "*")).strategy == Select::Strategy::ALL);
  REQUIRE(parse_select(create_select_query("ANY", "*")).strategy == Select::Strategy::ANY);
  REQUIRE(parse_select(create_select_query("LAST", "*")).strategy == Select::Strategy::LAST);
  REQUIRE(parse_select(create_select_query("MAX", "*")).strategy == Select::Strategy::MAX);
  REQUIRE(parse_select(create_select_query("NEXT", "*")).strategy == Select::Strategy::NEXT);
  REQUIRE(parse_select(create_select_query("STRICT", "*")).strategy == Select::Strategy::STRICT);
  REQUIRE(parse_select(create_select_query("", "*")).strategy == Select::Strategy::DEFAULT);
  // clang-format on
}

TEST_CASE("Select captures star correctly", "[Select, list_of_variables]") {
  REQUIRE(parse_select(create_select_query("ALL", "*")).is_star);
  REQUIRE(!parse_select(create_select_query("ALL", "T")).is_star);
}

TEST_CASE("Select captures list_of_variables correctly",
          "[Select, list_of_variables]") {
  ProjectionFormula* formula;
  std::set<std::string> vars;
  bool condition;

  formula = static_cast<ProjectionFormula*>(parse_select(create_select_query("", "A")).formula.get());
  vars = formula->variables;
  condition = vars.contains("A") && vars.size() == 1;
  REQUIRE(condition);

  formula = static_cast<ProjectionFormula*>(parse_select(create_select_query("", "A, B")).formula.get());
  vars = formula->variables;
  condition = vars.contains("A") && vars.contains("B") && vars.size() == 2;
  REQUIRE(condition);

  formula = static_cast<ProjectionFormula*>(parse_select(create_select_query("", "A, B, C")).formula.get());
  vars = formula->variables;
  condition = vars.contains("A") && vars.contains("B") && vars.contains("C")
              && vars.size() == 3;
  REQUIRE(condition);

  formula = static_cast<ProjectionFormula*>(parse_select(create_select_query("", "*")).formula.get());
  vars = formula->variables;
  condition = vars.size() == 0;
  REQUIRE(condition);

  formula = static_cast<ProjectionFormula*>(parse_select(create_select_query("", "A, A")).formula.get());
  vars = formula->variables;
  condition = vars.contains("A") && vars.size() == 1;
  REQUIRE(condition);
}
}  // namespace CORE::Internal::CEQL::UnitTests
