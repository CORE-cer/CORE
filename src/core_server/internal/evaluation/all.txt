<file ./physical_predicate/not_predicate.hpp>
#pragma once
#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <utility>

#include "cassert"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

class NotPredicate : public PhysicalPredicate {
 private:
  std::unique_ptr<PhysicalPredicate> predicate;

 public:
  NotPredicate(uint64_t event_type_id, std::unique_ptr<PhysicalPredicate> predicate)
      : PhysicalPredicate(event_type_id), predicate(std::move(predicate)) {}

  NotPredicate(std::set<uint64_t> admissible_event_types,
               std::unique_ptr<PhysicalPredicate> predicate)
      : PhysicalPredicate(admissible_event_types), predicate(std::move(predicate)) {}

  NotPredicate(std::unique_ptr<PhysicalPredicate> predicate)
      : PhysicalPredicate(), predicate(std::move(predicate)) {}

  ~NotPredicate() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override { return !predicate->eval(tuple); }

  bool eval(Types::EventWrapper& event) override { return !predicate->eval(event); }

  std::string to_string() const override { return "NOT " + predicate->to_string(); }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/and_predicate.hpp>
#pragma once
#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <tracy/Tracy.hpp>
#include <utility>
#include <vector>

#include "cassert"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

class AndPredicate : public PhysicalPredicate {
 private:
  std::vector<std::unique_ptr<PhysicalPredicate>> predicates;

 public:
  AndPredicate(uint64_t event_type_id,
               std::vector<std::unique_ptr<PhysicalPredicate>>&& predicates)
      : PhysicalPredicate(event_type_id), predicates(std::move(predicates)) {}

  AndPredicate(std::set<uint64_t> admissible_event_types,
               std::vector<std::unique_ptr<PhysicalPredicate>>&& predicates)
      : PhysicalPredicate(admissible_event_types), predicates(std::move(predicates)) {}

  AndPredicate(std::vector<std::unique_ptr<PhysicalPredicate>>&& predicates)
      : PhysicalPredicate(), predicates(std::move(predicates)) {}

  ~AndPredicate() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    ZoneScopedN("AndPredicate::eval()");
    for (auto& predicate : predicates) {
      if (!(predicate->eval(tuple))) {
        return false;
      }
    }
    return true;
  }

  bool eval(Types::EventWrapper& event) override {
    ZoneScopedN("AndPredicate::eval()");
    for (auto& predicate : predicates) {
      if (!(predicate->eval(event))) {
        return false;
      }
    }
    return true;
  }

  std::string to_string() const override {
    std::string out = predicates[0]->to_string();
    for (int i = 1; i < predicates.size(); i++) {
      out += " AND " + predicates[i]->to_string();
    }
    return out;
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/compare_math_exprs.hpp>
#pragma once
#include <cstdint>
#include <cwchar>
#include <memory>
#include <set>
#include <string>
#include <tracy/Tracy.hpp>

#include "cassert"
#include "comparison_type.hpp"
#include "core_server/internal/evaluation/physical_predicate/math_expr/math_expr.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <ComparisonType Comp, typename ValueType>
class CompareMathExprs : public PhysicalPredicate {
 private:
  std::unique_ptr<MathExpr<ValueType>> left;
  std::unique_ptr<MathExpr<ValueType>> right;

 public:
  CompareMathExprs(uint64_t event_type_id,
                   std::unique_ptr<MathExpr<ValueType>>&& left,
                   std::unique_ptr<MathExpr<ValueType>>&& right)
      : PhysicalPredicate(event_type_id), left(std::move(left)), right(std::move(right)) {}

  CompareMathExprs(std::set<uint64_t> admissible_event_types,
                   std::unique_ptr<MathExpr<ValueType>>&& left,
                   std::unique_ptr<MathExpr<ValueType>>&& right)
      : PhysicalPredicate(admissible_event_types),
        left(std::move(left)),
        right(std::move(right)) {}

  ~CompareMathExprs() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    ZoneScopedN("CompareMathExprs::eval()");
    // std::cout << to_string() << std::endl;
    if constexpr (Comp == ComparisonType::EQUALS) {
      return left->eval(tuple) == right->eval(tuple);
    } else if constexpr (Comp == ComparisonType::GREATER)
      return left->eval(tuple) > right->eval(tuple);
    else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
      return left->eval(tuple) >= right->eval(tuple);
    else if constexpr (Comp == ComparisonType::LESS_EQUALS)
      return left->eval(tuple) <= right->eval(tuple);
    else if constexpr (Comp == ComparisonType::LESS)
      return left->eval(tuple) < right->eval(tuple);
    else if constexpr (Comp == ComparisonType::NOT_EQUALS)
      return left->eval(tuple) != right->eval(tuple);
    else
      assert(false && "Operator() not implemented for some ComparisonType");
  }

  bool eval(Types::EventWrapper& event) override {
    ZoneScopedN("CompareMathExprs::eval()");
    // std::cout << to_string() << std::endl;
    if constexpr (Comp == ComparisonType::EQUALS) {
      return left->eval(event) == right->eval(event);
    } else if constexpr (Comp == ComparisonType::GREATER)
      return left->eval(event) > right->eval(event);
    else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
      return left->eval(event) >= right->eval(event);
    else if constexpr (Comp == ComparisonType::LESS_EQUALS)
      return left->eval(event) <= right->eval(event);
    else if constexpr (Comp == ComparisonType::LESS)
      return left->eval(event) < right->eval(event);
    else if constexpr (Comp == ComparisonType::NOT_EQUALS)
      return left->eval(event) != right->eval(event);
    else
      assert(false && "Operator() not implemented for some ComparisonType");
  }

  std::string to_string() const override {
    if constexpr (Comp == ComparisonType::EQUALS)
      return left->to_string() + "==" + right->to_string();
    else if constexpr (Comp == ComparisonType::GREATER)
      return left->to_string() + ">" + right->to_string();
    else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
      return left->to_string() + ">=" + right->to_string();
    else if constexpr (Comp == ComparisonType::LESS_EQUALS)
      return left->to_string() + "<=" + right->to_string();
    else if constexpr (Comp == ComparisonType::LESS)
      return left->to_string() + "<" + right->to_string();
    else if constexpr (Comp == ComparisonType::NOT_EQUALS)
      return left->to_string() + "!=" + right->to_string();
    else
      assert(false && "to_string() not implemented for some ComparisonType");
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/or_predicate.hpp>
#pragma once
#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "cassert"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

class OrPredicate : public PhysicalPredicate {
 private:
  std::vector<std::unique_ptr<PhysicalPredicate>> predicates;

 public:
  OrPredicate(uint64_t event_type_id,
              std::vector<std::unique_ptr<PhysicalPredicate>>&& predicates)
      : PhysicalPredicate(event_type_id), predicates(std::move(predicates)) {}

  OrPredicate(std::set<uint64_t> admissible_event_types,
              std::vector<std::unique_ptr<PhysicalPredicate>>&& predicates)
      : PhysicalPredicate(admissible_event_types), predicates(std::move(predicates)) {}

  OrPredicate(std::vector<std::unique_ptr<PhysicalPredicate>>&& predicates)
      : PhysicalPredicate(), predicates(std::move(predicates)) {}

  ~OrPredicate() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    for (auto& predicate : predicates) {
      // We want to check for event_types individually inside the or.
      if ((*predicate)(tuple)) {
        return true;
      }
    }
    return false;
  }

  bool eval(Types::EventWrapper& event) override {
    for (auto& predicate : predicates) {
      // We want to check for event_types individually inside the or.
      if ((*predicate)(event)) {
        return true;
      }
    }
    return false;
  }

  std::string to_string() const override {
    std::string out = predicates[0]->to_string();
    for (int i = 1; i < predicates.size(); i++) {
      out += " OR " + predicates[i]->to_string();
    }
    return out;
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/subtraction.hpp>
#pragma once
#include <cassert>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class Subtraction : public MathExpr<Type> {
 public:
  std::unique_ptr<MathExpr<Type>> left;
  std::unique_ptr<MathExpr<Type>> right;
  virtual ~Subtraction() = default;

  Subtraction(std::unique_ptr<MathExpr<Type>>&& left,
              std::unique_ptr<MathExpr<Type>>&& right)
      : left(std::move(left)), right(std::move(right)) {}

  std::unique_ptr<MathExpr<Type>> clone() const override {
    return std::make_unique<Subtraction<Type>>(left->clone(), right->clone());
  }

  Type eval(RingTupleQueue::Tuple& tuple) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Minus is only valid for arithmetic vals");
      throw std::logic_error("Minus is only valid for arithmetic vals");
    } else
      return left->eval(tuple) - right->eval(tuple);
  }

  Type eval(Types::EventWrapper& event) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Minus is only valid for arithmetic vals");
      throw std::logic_error("Minus is only valid for arithmetic vals");
    } else
      return left->eval(event) - right->eval(event);
  }

  std::string to_string() const override {
    return "(" + left->to_string() + " - " + right->to_string() + ")";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/multiplication.hpp>
#pragma once
#include <cassert>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class Multiplication : public MathExpr<Type> {
 public:
  std::unique_ptr<MathExpr<Type>> left;
  std::unique_ptr<MathExpr<Type>> right;
  virtual ~Multiplication() = default;

  Multiplication(std::unique_ptr<MathExpr<Type>>&& left,
                 std::unique_ptr<MathExpr<Type>>&& right)
      : left(std::move(left)), right(std::move(right)) {}

  std::unique_ptr<MathExpr<Type>> clone() const override {
    return std::make_unique<Multiplication<Type>>(left->clone(), right->clone());
  }

  Type eval(RingTupleQueue::Tuple& tuple) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Multiplication is only valid for arithmetic vals");
      throw std::logic_error("Minus is only valid for arithmetic vals");
    } else
      return left->eval(tuple) * right->eval(tuple);
  }

  Type eval(Types::EventWrapper& event) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Multiplication is only valid for arithmetic vals");
      throw std::logic_error("Minus is only valid for arithmetic vals");
    } else
      return left->eval(event) * right->eval(event);
  }

  std::string to_string() const override {
    return "(" + left->to_string() + " * " + right->to_string() + ")";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/division.hpp>
#pragma once
#include <cassert>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class Division : public MathExpr<Type> {
 public:
  std::unique_ptr<MathExpr<Type>> left;
  std::unique_ptr<MathExpr<Type>> right;
  virtual ~Division() = default;

  Division(std::unique_ptr<MathExpr<Type>>&& left, std::unique_ptr<MathExpr<Type>>&& right)
      : left(std::move(left)), right(std::move(right)) {}

  std::unique_ptr<MathExpr<Type>> clone() const override {
    return std::make_unique<Division<Type>>(left->clone(), right->clone());
  }

  Type eval(RingTupleQueue::Tuple& tuple) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Division is only valid for arithmetic vals");
      throw std::logic_error("Division is only valid for arithmetic vals");
    } else
      return left->eval(tuple) / right->eval(tuple);
  }

  Type eval(Types::EventWrapper& event) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Division is only valid for arithmetic vals");
      throw std::logic_error("Division is only valid for arithmetic vals");
    } else
      return left->eval(event) / right->eval(event);
  }

  std::string to_string() const override {
    return "(" + left->to_string() + " / " + right->to_string() + ")";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/math_expr.hpp>
#pragma once

#include <memory>
#include <string>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class MathExpr {
 public:
  virtual std::unique_ptr<MathExpr<Type>> clone() const = 0;
  virtual ~MathExpr() = default;
  virtual Type eval(RingTupleQueue::Tuple&) = 0;
  virtual Type eval(Types::EventWrapper&) = 0;
  virtual std::string to_string() const = 0;
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/addition.hpp>
#pragma once
#include <cassert>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class Addition : public MathExpr<Type> {
  std::unique_ptr<MathExpr<Type>> left;
  std::unique_ptr<MathExpr<Type>> right;

 public:
  Addition(std::unique_ptr<MathExpr<Type>>&& left, std::unique_ptr<MathExpr<Type>>&& right)
      : left(std::move(left)), right(std::move(right)) {}

  std::unique_ptr<MathExpr<Type>> clone() const override {
    return std::make_unique<Addition<Type>>(left->clone(), right->clone());
  }

  ~Addition() override = default;

  Type eval(RingTupleQueue::Tuple& tuple) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Addition is only valid for arithmetic vals");
      throw std::logic_error("Addition is only valid for arithmetic vals");
    } else
      return left->eval(tuple) + right->eval(tuple);
  }

  Type eval(Types::EventWrapper& event) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Addition is only valid for arithmetic vals");
      throw std::logic_error("Addition is only valid for arithmetic vals");
    } else
      return left->eval(event) + right->eval(event);
  }

  std::string to_string() const override {
    return "(" + left->to_string() + " + " + right->to_string() + ")";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/non_strongly_typed_attribute.hpp>
#pragma once
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ctime>
#include <memory>
#include <string>
#include <string_view>
#include <type_traits>

#include "core_server/internal/coordination/query_catalog.hpp"
#include "core_server/internal/evaluation/physical_predicate/compare_with_attribute.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "core_server/internal/stream/ring_tuple_queue/value.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/aliases/event_type_id.hpp"
#include "shared/datatypes/catalog/datatypes.hpp"
#include "shared/datatypes/catalog/event_info.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename GlobalType>
class NonStronglyTypedAttribute : public MathExpr<GlobalType> {
 public:
  std::string name;
  QueryCatalog& query_catalog;

  // If Type == std::string_view, then the underlying string is stored, if not
  // a char is stored.
  typename std::conditional<std::is_same_v<GlobalType, std::string_view>,
                            std::string,
                            char>::type stored_string;

  NonStronglyTypedAttribute(std::string name, QueryCatalog& query_catalog)
      : name(name), query_catalog(query_catalog) {}

  std::unique_ptr<MathExpr<GlobalType>> clone() const override {
    return std::make_unique<NonStronglyTypedAttribute<GlobalType>>(name, query_catalog);
  }

  ~NonStronglyTypedAttribute() override = default;

  GlobalType eval(RingTupleQueue::Tuple& tuple) override {
    // It must be determined at the predicate level whether this eval
    // makes sense for the tuple.
    size_t pos = query_catalog.get_index_attribute(tuple.id(), name);
    const Types::EventInfo& event_info = query_catalog.get_event_info(tuple.id());
    assert(event_info.attribute_names_to_ids.contains(name));
    Types::ValueTypes attribute_type = event_info.attributes_info[pos].value_type;

    switch (attribute_type) {
      case Types::ValueTypes::INT64:
        return eval<int64_t>(tuple, pos);
      case Types::ValueTypes::DOUBLE:
        return eval<double>(tuple, pos);
      case Types::ValueTypes::BOOL:
        return eval<bool>(tuple, pos);
      case Types::ValueTypes::STRING_VIEW:
        return eval<std::string_view>(tuple, pos);
      case Types::ValueTypes::DATE:
        return eval<std::time_t>(tuple, pos);
      default:
        assert(false
               && "A value type was not implemented in NonStronglytypedAttribute eval");
        break;
    }
    return {};  // For warning not to appear.
  }

  GlobalType eval(Types::EventWrapper& event) override {
    // It must be determined at the predicate level whether this eval
    // makes sense for the tuple.
    Types::UniqueEventTypeId unique_event_id = event.get_unique_event_type_id();
    size_t pos = query_catalog.get_index_attribute(unique_event_id, name);
    const Types::EventInfo& event_info = query_catalog.get_event_info(unique_event_id);
    assert(event_info.attribute_names_to_ids.contains(name));
    Types::ValueTypes attribute_type = event_info.attributes_info[pos].value_type;

    switch (attribute_type) {
      case Types::ValueTypes::INT64:
        return eval<int64_t>(event, pos);
      case Types::ValueTypes::DOUBLE:
        return eval<double>(event, pos);
      case Types::ValueTypes::BOOL:
        return eval<bool>(event, pos);
      case Types::ValueTypes::STRING_VIEW:
        return eval<std::string_view>(event, pos);
      case Types::ValueTypes::DATE:
        return eval<std::time_t>(event, pos);
      default:
        assert(false
               && "A value type was not implemented in NonStronglytypedAttribute eval");
        break;
    }
    return {};  // For warning not to appear.
  }

  template <typename LocalType>
  GlobalType eval(RingTupleQueue::Tuple& tuple, size_t pos) {
    RingTupleQueue::Value<LocalType> val(tuple[pos]);
    if constexpr (std::is_same_v<GlobalType, LocalType>) {
      return val.get();
    } else if constexpr (std::is_same_v<GlobalType, std::string_view>) {
      stored_string = std::to_string(val.get());  // It is not a string already.
      return stored_string;
    } else if constexpr (std::is_same_v<LocalType, std::string_view>) {
      assert(false
             && "Local Type is string and global type is not, this should never happen.");
      return {};
    } else {
      return static_cast<GlobalType>(val.get());
    }
  }

  template <typename LocalType>
  GlobalType eval(Types::EventWrapper& event, size_t pos) {
    typename ToCoreType<LocalType>::type
      val = event.get_attribute_at_index<typename ToCoreType<LocalType>::type>(pos);
    if constexpr (std::is_same_v<GlobalType, LocalType>) {
      return val.val;
    } else if constexpr (std::is_same_v<GlobalType, std::string_view>) {
      stored_string = std::to_string(val.val);  // It is not a string already.
      return stored_string;
    } else if constexpr (std::is_same_v<LocalType, std::string_view>) {
      assert(false
             && "Local Type is string and global type is not, this should never happen.");
      return {};
    } else {
      return static_cast<GlobalType>(val.val);
    }
  }

  std::string to_string() const override { return name; }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/attribute.hpp>
#pragma once
#include <cassert>
#include <cstddef>
#include <memory>
#include <string>
#include <string_view>
#include <tracy/Tracy.hpp>
#include <type_traits>

#include "core_server/internal/evaluation/physical_predicate/compare_with_attribute.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "core_server/internal/stream/ring_tuple_queue/value.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename GlobalType, typename LocalType>
class Attribute : public MathExpr<GlobalType> {
 public:
  size_t pos;

  // If Type == std::string_view, then the underlying string is stored, if not
  // a char is stored.
  typename std::conditional<std::is_same_v<GlobalType, std::string_view>,
                            std::string,
                            char>::type stored_string;

  Attribute(size_t pos) : pos(pos) {}

  std::unique_ptr<MathExpr<GlobalType>> clone() const override {
    return std::make_unique<Attribute<GlobalType, LocalType>>(pos);
  }

  ~Attribute() override = default;

  GlobalType eval(RingTupleQueue::Tuple& tuple) override {
    ZoneScopedN("Attribute::eval(tuple)");
    RingTupleQueue::Value<LocalType> val(tuple[pos]);
    if constexpr (std::is_same_v<GlobalType, LocalType>) {
      return val.get();
    } else if constexpr (std::is_same_v<GlobalType, std::string_view>) {
      stored_string = std::to_string(val.get());  // It is not a string already.
      return stored_string;
    } else {
      return static_cast<GlobalType>(val.get());
    }
  }

  GlobalType eval(Types::EventWrapper& event) override {
    ZoneScopedN("Attribute::eval(event)");
    typename ToCoreType<LocalType>::type
      val = event.get_attribute_at_index<typename ToCoreType<LocalType>::type>(pos);
    if constexpr (std::is_same_v<GlobalType, LocalType>) {
      return val.val;
    } else if constexpr (std::is_same_v<GlobalType, std::string_view>) {
      stored_string = std::to_string(val.val);  // It is not a string already.
      return stored_string;
    } else {
      return static_cast<GlobalType>(val.val);
    }
  }

  std::string to_string() const override {
    return "Attribute[" + std::to_string(pos) + "]";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/literal.hpp>
#pragma once
#include <memory>
#include <string>
#include <string_view>
#include <tracy/Tracy.hpp>
#include <type_traits>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class Literal : public MathExpr<Type> {
 public:
  Type val;

  // If Type == std::string_view, then the underlying string is stored, if not
  // a char is stored. (Simpler than doing specialization of the Literal Class)
  typename std::conditional<std::is_same_v<Type, std::string_view>, std::string, char>::type
    stored_string;
  virtual ~Literal() override = default;

  Literal(Type val) : val(val) {
    // Ensure that the underlying memory of std::string_view stays alive.
    if constexpr (std::is_same_v<Type, std::string_view>) {
      stored_string = std::string{val};
      this->val = stored_string;
    }
  }

  std::unique_ptr<MathExpr<Type>> clone() const override {
    return std::make_unique<Literal<Type>>(val);
  }

  Type eval(RingTupleQueue::Tuple& tuple) override {
    ZoneScopedN("Literal::eval()");
    return val;
  }

  Type eval(Types::EventWrapper& event) override {
    ZoneScopedN("Literal::eval()");
    return val;
  }

  std::string to_string() const override {
    if constexpr (std::is_same_v<Type, std::string_view>) {
      return std::string{val};
    } else {
      return std::to_string(val);
    }
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/math_expr/modulo.hpp>
#pragma once
#include <cassert>
#include <memory>
#include <stdexcept>
#include <string>
#include <type_traits>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "math_expr.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename Type>
class Modulo : public MathExpr<Type> {
 public:
  std::unique_ptr<MathExpr<Type>> left;
  std::unique_ptr<MathExpr<Type>> right;
  virtual ~Modulo() = default;

  Modulo(std::unique_ptr<MathExpr<Type>>&& left, std::unique_ptr<MathExpr<Type>>&& right)
      : left(std::move(left)), right(std::move(right)) {}

  std::unique_ptr<MathExpr<Type>> clone() const override {
    return std::make_unique<Modulo<Type>>(left->clone(), right->clone());
  }

  Type eval(RingTupleQueue::Tuple& tuple) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Modulo is only valid for arithmetic vals");
      throw std::logic_error("Modulo is only valid for arithmetic vals");
    } else if constexpr (std::is_same_v<Type, double>) {
      throw std::runtime_error("Cannot eval a modulo on double types");
    } else {
      return left->eval(tuple) % right->eval(tuple);
    }
  }

  Type eval(Types::EventWrapper& event) override {
    if constexpr (!std::is_arithmetic<Type>::value) {
      assert(false && "Modulo is only valid for arithmetic vals");
      throw std::logic_error("Modulo is only valid for arithmetic vals");
    } else if constexpr (std::is_same_v<Type, double>) {
      throw std::runtime_error("Cannot eval a modulo on double types");
    } else {
      return left->eval(event) % right->eval(event);
    }
  }

  std::string to_string() const override {
    return "(" + left->to_string() + " % " + right->to_string() + ")";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/comparison_type.hpp>
#pragma once

namespace CORE::Internal::CEA {
enum ComparisonType {
  EQUALS,
  GREATER,
  GREATER_EQUALS,
  LESS_EQUALS,
  LESS,
  NOT_EQUALS,
};
}
</file>
<file ./physical_predicate/compare_with_constant.hpp>
#pragma once

#include <cstddef>
#include <cstdint>
#include <set>
#include <string>
#include <tracy/Tracy.hpp>
#include <type_traits>

#include "cassert"
#include "comparison_type.hpp"
#include "core_server/internal/evaluation/physical_predicate/compare_with_attribute.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "core_server/internal/stream/ring_tuple_queue/value.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <ComparisonType Comp, typename ValueType>
class CompareWithConstant : public PhysicalPredicate {
 private:
  size_t pos_to_compare;
  ValueType constant_val;

 public:
  CompareWithConstant(uint64_t event_type_id, size_t pos_to_compare, ValueType constant_val)
      : PhysicalPredicate(event_type_id),
        pos_to_compare(pos_to_compare),
        constant_val(constant_val) {}

  CompareWithConstant(std::set<uint64_t> admissible_event_types,
                      size_t pos_to_compare,
                      ValueType constant_val)
      : PhysicalPredicate(admissible_event_types),
        pos_to_compare(pos_to_compare),
        constant_val(constant_val) {}

  ~CompareWithConstant() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    ZoneScopedN("CompareWithConstant::eval()");
    uint64_t* pos = tuple[pos_to_compare];
    RingTupleQueue::Value<ValueType> attribute_val(pos);
    if constexpr (Comp == ComparisonType::EQUALS)
      return attribute_val.get() == constant_val;
    else if constexpr (Comp == ComparisonType::GREATER)
      return attribute_val.get() > constant_val;
    else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
      return attribute_val.get() >= constant_val;
    else if constexpr (Comp == ComparisonType::LESS_EQUALS)
      return attribute_val.get() <= constant_val;
    else if constexpr (Comp == ComparisonType::LESS)
      return attribute_val.get() < constant_val;
    else if constexpr (Comp == ComparisonType::NOT_EQUALS)
      return attribute_val.get() != constant_val;
    else
      assert(false && "Operator() not implemented for some ComparisonType");
  }

  bool eval(Types::EventWrapper& event) override {
    ZoneScopedN("CompareWithConstant::eval()");
    typename ToCoreType<ValueType>::type
      attribute_val = event.get_attribute_at_index<typename ToCoreType<ValueType>::type>(
        pos_to_compare);
    if constexpr (Comp == ComparisonType::EQUALS)
      return attribute_val.val == constant_val;
    else if constexpr (Comp == ComparisonType::GREATER)
      return attribute_val.val > constant_val;
    else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
      return attribute_val.val >= constant_val;
    else if constexpr (Comp == ComparisonType::LESS_EQUALS)
      return attribute_val.val <= constant_val;
    else if constexpr (Comp == ComparisonType::LESS)
      return attribute_val.val < constant_val;
    else if constexpr (Comp == ComparisonType::NOT_EQUALS)
      return attribute_val.val != constant_val;
    else
      assert(false && "Operator() not implemented for some ComparisonType");
  }

  template <typename T, typename = std::void_t<>>
  struct has_to_string : std::false_type {};

  template <typename T>
  struct has_to_string<T, std::void_t<decltype(std::to_string(std::declval<T>()))>>
      : std::true_type {};

  template <typename T>
  inline static constexpr bool has_to_string_v = has_to_string<T>::value;

  std::string to_string() const override {
    if constexpr (!has_to_string_v<ValueType>) {
      if constexpr (Comp == ComparisonType::EQUALS)
        return "Event[" + std::to_string(pos_to_compare) + "] == some chrono";
      else if constexpr (Comp == ComparisonType::GREATER)
        return "Event[" + std::to_string(pos_to_compare) + "] > " + "some chrono";
      else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
        return "Event[" + std::to_string(pos_to_compare) + "] >= some chrono";
      else if constexpr (Comp == ComparisonType::LESS_EQUALS)
        return "Event[" + std::to_string(pos_to_compare) + "] <= some chrono";
      else if constexpr (Comp == ComparisonType::LESS)
        return "Event[" + std::to_string(pos_to_compare) + "] < " + "some chrono";
      else if constexpr (Comp == ComparisonType::NOT_EQUALS)
        return "Event[" + std::to_string(pos_to_compare) + "] != some chrono ";
      else
        assert(false && "to_string() not implemented for some ComparisonType");
    } else {
      if constexpr (Comp == ComparisonType::EQUALS)
        return "Event[" + std::to_string(pos_to_compare)
               + "] == " + std::to_string(constant_val);
      else if constexpr (Comp == ComparisonType::GREATER)
        return "Event[" + std::to_string(pos_to_compare) + "] > "
               + std::to_string(constant_val);
      else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
        return "Event[" + std::to_string(pos_to_compare)
               + "] >= " + std::to_string(constant_val);
      else if constexpr (Comp == ComparisonType::LESS_EQUALS)
        return "Event[" + std::to_string(pos_to_compare)
               + "] <= " + std::to_string(constant_val);
      else if constexpr (Comp == ComparisonType::LESS)
        return "Event[" + std::to_string(pos_to_compare) + "] < "
               + std::to_string(constant_val);
      else if constexpr (Comp == ComparisonType::NOT_EQUALS)
        return "Event[" + std::to_string(pos_to_compare)
               + "] != " + std::to_string(constant_val);
      else
        assert(false && "to_string() not implemented for some ComparisonType");
    }
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/compare_with_attribute.hpp>
#pragma once

#include <cstdint>
#include <cwchar>
#include <set>
#include <string>
#include <string_view>
#include <tracy/Tracy.hpp>

#include "cassert"
#include "comparison_type.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "core_server/internal/stream/ring_tuple_queue/value.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"
#include "shared/datatypes/value.hpp"

namespace CORE::Internal::CEA {

template <typename T>
struct ToCoreType;

template <>
struct ToCoreType<int64_t> {
  using type = Types::IntValue;
};

template <>
struct ToCoreType<double> {
  using type = Types::DoubleValue;
};

template <>
struct ToCoreType<bool> {
  using type = Types::BoolValue;
};

template <>
struct ToCoreType<std::string_view> {
  using type = Types::StringValue;
};

template <ComparisonType Comp, typename LeftValueType, typename RightValueType>
class CompareWithAttribute : public PhysicalPredicate {
 private:
  size_t first_pos;
  size_t second_pos;

 public:
  CompareWithAttribute(uint64_t event_type_id, size_t first_pos, size_t second_pos)
      : PhysicalPredicate(event_type_id), first_pos(first_pos), second_pos(second_pos) {}

  CompareWithAttribute(std::set<uint64_t> admissible_event_types,
                       size_t first_pos,
                       size_t second_pos)
      : PhysicalPredicate(admissible_event_types),
        first_pos(first_pos),
        second_pos(second_pos) {}

  ~CompareWithAttribute() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    ZoneScopedN("CompareWithAttribute::eval()");
    uint64_t* pos1 = tuple[first_pos];
    uint64_t* pos2 = tuple[second_pos];
    RingTupleQueue::Value<LeftValueType> first_val(pos1);
    RingTupleQueue::Value<RightValueType> second_val(pos2);
    if constexpr (!std::is_same_v<LeftValueType, RightValueType>
                  && (std::is_same_v<LeftValueType, std::string_view>
                      || std::is_same_v<RightValueType, std::string_view>)) {
      return false;  // Cannot compare string with non string.
    } else {
      if constexpr (Comp == ComparisonType::EQUALS)
        return first_val.get() == second_val.get();
      else if constexpr (Comp == ComparisonType::GREATER)
        return first_val.get() > second_val.get();
      else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
        return first_val.get() >= second_val.get();
      else if constexpr (Comp == ComparisonType::LESS_EQUALS)
        return first_val.get() <= second_val.get();
      else if constexpr (Comp == ComparisonType::LESS)
        return first_val.get() < second_val.get();

      else if constexpr (Comp == ComparisonType::NOT_EQUALS)
        return first_val.get() != second_val.get();
      else
        assert(false && "Operator() not implemented for some ComparisonType");
    }
  }

  bool eval(Types::EventWrapper& event) override {
    ZoneScopedN("CompareWithAttribute::eval()");
    typename ToCoreType<LeftValueType>::type
      pos1 = event.get_attribute_at_index<typename ToCoreType<LeftValueType>::type>(first_pos);
    typename ToCoreType<RightValueType>::type
      pos2 = event.get_attribute_at_index<typename ToCoreType<RightValueType>::type>(second_pos);
    if constexpr (!std::is_same_v<LeftValueType, RightValueType>
                  && (std::is_same_v<LeftValueType, std::string_view>
                      || std::is_same_v<RightValueType, std::string_view>)) {
      return false;  // Cannot compare string with non string.
    } else {
      if constexpr (Comp == ComparisonType::EQUALS)
        return pos1.val == pos2.val;
      else if constexpr (Comp == ComparisonType::GREATER)
        return pos1.val > pos2.val;
      else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
        return pos1.val >= pos2.val;
      else if constexpr (Comp == ComparisonType::LESS_EQUALS)
        return pos1.val <= pos2.val;
      else if constexpr (Comp == ComparisonType::LESS)
        return pos1.val < pos2.val;
      else if constexpr (Comp == ComparisonType::NOT_EQUALS)
        return pos1.val != pos2.val;
      else
        assert(false && "Operator() not implemented for some ComparisonType");
    }
  }

  std::string to_string() const override {
    if constexpr (Comp == ComparisonType::EQUALS)
      return "Event[" + std::to_string(first_pos) + "] == Event["
             + std::to_string(second_pos) + "]";
    else if constexpr (Comp == ComparisonType::GREATER)
      return "Event[" + std::to_string(first_pos) + "] > Event["
             + std::to_string(second_pos) + "]";
    else if constexpr (Comp == ComparisonType::GREATER_EQUALS)
      return "Event[" + std::to_string(first_pos) + "] >= Event["
             + std::to_string(second_pos) + "]";
    else if constexpr (Comp == ComparisonType::LESS_EQUALS)
      return "Event[" + std::to_string(first_pos) + "] <= Event["
             + std::to_string(second_pos) + "]";
    else if constexpr (Comp == ComparisonType::LESS)
      return "Event[" + std::to_string(first_pos) + "] < Event["
             + std::to_string(second_pos) + "]";
    else if constexpr (Comp == ComparisonType::NOT_EQUALS)
      return "Event[" + std::to_string(first_pos) + "] != Event["
             + std::to_string(second_pos) + "]";
    else
      assert(false && "to_string() not implemented for some ComparisonType");
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/check_stream_type_predicate.hpp>
#pragma once

#include <string>

#include "cassert"
#include "core_server/internal/coordination/query_catalog.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/aliases/event_type_id.hpp"
#include "shared/datatypes/aliases/stream_type_id.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

class CheckStreamTypePredicate : public PhysicalPredicate {
  QueryCatalog& query_catalog;
  Types::StreamTypeId stream_type_id;

 public:
  CheckStreamTypePredicate(Types::StreamTypeId stream_type_id, QueryCatalog& query_catalog)
      : PhysicalPredicate(),
        stream_type_id(stream_type_id),
        query_catalog(query_catalog) {}

  ~CheckStreamTypePredicate() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    Types::UniqueEventTypeId tuple_unique_event_id = tuple.id();

    // If errors out, probably sent a tuple that is not in the from for this query
    Types::StreamTypeId tuple_stream_type_id = query_catalog.stream_id_from_unique_event_id(
      tuple_unique_event_id);

    return tuple_stream_type_id == stream_type_id;
  }

  bool eval(Types::EventWrapper& event) override {
    Types::UniqueEventTypeId unique_event_id = event.get_unique_event_type_id();

    // If errors out, probably sent a tuple that is not in the from for this query
    Types::StreamTypeId tuple_stream_type_id = query_catalog.stream_id_from_unique_event_id(
      unique_event_id);

    return tuple_stream_type_id == stream_type_id;
  }

  std::string to_string() const override {
    std::string out = "IS ";
    for (auto id : admissible_event_types) {
      out += std::to_string(id) + " ";
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/physical_predicate.hpp>
#pragma once

#include <cstdint>
#include <set>
#include <string>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "shared/datatypes/aliases/event_type_id.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

class PhysicalPredicate {
 public:
  virtual ~PhysicalPredicate() = default;

  std::set<Types::UniqueEventTypeId> admissible_event_types;

  bool admits_any_event_type = false;

  PhysicalPredicate(Types::UniqueEventTypeId event_type_id)
      : admissible_event_types({event_type_id}) {}

  PhysicalPredicate(std::set<uint64_t> admissible_event_types)
      : admissible_event_types(admissible_event_types) {}

  PhysicalPredicate() : admits_any_event_type(true) {}

  bool operator()(RingTupleQueue::Tuple& tuple) {
    // admits_any_event_type is second in the condition because it is rare
    // that the operator() will be used on such a type.
    if (admissible_event_types.contains(tuple.id()) || admits_any_event_type) {
      bool tuple_eval = eval(tuple);
      return tuple_eval;
    }
    return false;
  }

  bool operator()(Types::EventWrapper& event) {
    // admits_any_event_type is second in the condition because it is rare
    // that the operator() will be used on such a type.
    Types::UniqueEventTypeId unique_event_id = event.get_unique_event_type_id();
    if (admissible_event_types.contains(unique_event_id || admits_any_event_type)) {
      bool event_eval = eval(event);
      return event_eval;
    }
    return false;
  }

  virtual bool eval(RingTupleQueue::Tuple& tuple) = 0;

  virtual bool eval(Types::EventWrapper& event_wrapper) = 0;

  std::string complete_info_string() const {
    std::string out = "admits any event type: " + std::to_string(admits_any_event_type)
                      + "\n" + " admissible event types:";
    for (auto& event_type : admissible_event_types) {
      out += " " + std::to_string(event_type);
    }
    out += "\n repr: ";
    return out + to_string();
  }

  virtual std::string to_string() const = 0;
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/in_range_predicate.hpp>
#pragma once

#include <cstdint>
#include <memory>
#include <set>
#include <string>

#include "core_server/internal/evaluation/physical_predicate/math_expr/math_expr.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

template <typename ValueType>
class InRangePredicate : public PhysicalPredicate {
 private:
  std::unique_ptr<MathExpr<ValueType>> left;
  std::unique_ptr<MathExpr<ValueType>> lower_bound;
  std::unique_ptr<MathExpr<ValueType>> upper_bound;

 public:
  InRangePredicate(uint64_t event_type_id,
                   std::unique_ptr<MathExpr<ValueType>>&& left,
                   std::unique_ptr<MathExpr<ValueType>>&& lower_bound,
                   std::unique_ptr<MathExpr<ValueType>>&& upper_bound)
      : PhysicalPredicate(event_type_id),
        left(std::move(left)),
        lower_bound(std::move(lower_bound)),
        upper_bound(std::move(upper_bound)) {}

  InRangePredicate(std::set<uint64_t> admissible_event_types,
                   std::unique_ptr<MathExpr<ValueType>>&& left,
                   std::unique_ptr<MathExpr<ValueType>>&& lower_bound,
                   std::unique_ptr<MathExpr<ValueType>>&& upper_bound)
      : PhysicalPredicate(admissible_event_types),
        left(std::move(left)),
        lower_bound(std::move(lower_bound)),
        upper_bound(std::move(upper_bound)) {}

  ~InRangePredicate() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    return (left->eval(tuple) >= lower_bound->eval(tuple))
           && (left->eval(tuple) <= upper_bound->eval(tuple));
  }

  bool eval(Types::EventWrapper& event) override {
    return (left->eval(event) >= lower_bound->eval(event))
           && (left->eval(event) <= upper_bound->eval(event));
  }

  std::string to_string() const override {
    return left->to_string() + "IN RANGE (" + lower_bound->to_string()
           + upper_bound->to_string() + ")";
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/like_predicate/compare_with_regex_strongly_typed.hpp>
#pragma once

#include <re2/re2.h>

#include <cstddef>
#include <cstdint>
#include <string>
#include <string_view>

#include "core_server/internal/evaluation/physical_predicate/physical_predicate.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "core_server/internal/stream/ring_tuple_queue/value.hpp"
#include "shared/datatypes/eventWrapper.hpp"
#include "shared/datatypes/value.hpp"

namespace CORE::Internal::CEA {
class CompareWithRegexStronglyTyped : public PhysicalPredicate {
 private:
  size_t pos_to_compare;
  std::string regex_string;
  re2::RE2 regex_compiled;

 public:
  CompareWithRegexStronglyTyped(uint64_t event_type_id,
                                size_t pos_to_compare,
                                std::string&& regex)
      : PhysicalPredicate(event_type_id),
        pos_to_compare(pos_to_compare),
        regex_string(regex),
        regex_compiled(regex) {}

  ~CompareWithRegexStronglyTyped() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    uint64_t* pos = tuple[pos_to_compare];
    RingTupleQueue::Value<std::string_view> attribute_val(pos);
    return re2::RE2::FullMatch(attribute_val.get(), regex_compiled);
  }

  bool eval(Types::EventWrapper& event) override {
    const Types::StringValue attribute_val = event.get_attribute_at_index<Types::StringValue>(pos_to_compare);
    return re2::RE2::FullMatch(attribute_val.val, regex_compiled);
  }

  std::string to_string() const override {
    return "Event[" + std::to_string(pos_to_compare) + "] (regex match) "
           + regex_string.data();
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/like_predicate/compare_with_regex_weakly_typed.hpp>
#pragma once

#include <re2/re2.h>

#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <string_view>
#include <utility>

#include "core_server/internal/evaluation/physical_predicate/math_expr/non_strongly_typed_attribute.hpp"
#include "core_server/internal/evaluation/physical_predicate/physical_predicate.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {
class CompareWithRegexWeaklyTyped : public PhysicalPredicate {
 private:
  std::unique_ptr<NonStronglyTypedAttribute<std::string_view>> left;
  std::string_view regex_string;
  re2::RE2 regex_compiled;

 public:
  CompareWithRegexWeaklyTyped(
    std::set<uint64_t> admissible_event_types,
    std::unique_ptr<NonStronglyTypedAttribute<std::string_view>>&& left,
    std::string&& regex)
      : PhysicalPredicate(admissible_event_types),
        left(std::move(left)),
        regex_string(regex),
        regex_compiled(regex) {}

  ~CompareWithRegexWeaklyTyped() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    return re2::RE2::FullMatch(left->eval(tuple), regex_compiled);
  }

  bool eval(Types::EventWrapper& event) override {
    return re2::RE2::FullMatch(left->eval(event), regex_compiled);
  }

  std::string to_string() const override {
    return left->to_string() + " (regex match) " + regex_string.data();
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./physical_predicate/check_event_type_predicate.hpp>
#pragma once

#include <string>

#include "cassert"
#include "core_server/internal/coordination/query_catalog.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "physical_predicate.hpp"
#include "shared/datatypes/aliases/event_type_id.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::CEA {

class CheckEventNamePredicate : public PhysicalPredicate {
  QueryCatalog& query_catalog;
  Types::EventNameTypeId event_name_type_id;

 public:
  CheckEventNamePredicate(Types::EventNameTypeId event_name_type_id,
                          QueryCatalog& query_catalog)
      : PhysicalPredicate(),
        event_name_type_id(event_name_type_id),
        query_catalog(query_catalog) {}

  ~CheckEventNamePredicate() override = default;

  bool eval(RingTupleQueue::Tuple& tuple) override {
    Types::UniqueEventTypeId tuple_unique_event_id = tuple.id();

    Types::EventNameTypeId
      tuple_event_name_type_id = query_catalog.event_name_id_from_unique_event_id(
        tuple_unique_event_id);

    return tuple_event_name_type_id == event_name_type_id;
  }

  bool eval(Types::EventWrapper& event) override {
    Types::UniqueEventTypeId unique_event_id = event.get_unique_event_type_id();

    Types::EventNameTypeId
      tuple_event_name_type_id = query_catalog.event_name_id_from_unique_event_id(
        unique_event_id);

    return tuple_event_name_type_id == event_name_type_id;
  }

  std::string to_string() const override {
    std::string out = "IS ";
    for (auto id : admissible_event_types) {
      out += std::to_string(id) + " ";
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./cea/cea.hpp>
#pragma once

#include <gmpxx.h>

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <set>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/optimizations/add_unique_initial_state.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/optimizations/remove_epsilon_transitions.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/optimizations/remove_unreachable_states.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/optimizations/remove_useless_states.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"

namespace CORE::Internal::CEA {
struct CEA {
 public:
  using IsMarked = bool;
  using NodeId = uint64_t;
  using Transition = std::tuple<PredicateSet, IsMarked, NodeId>;
  using States = mpz_class;

  uint64_t amount_of_states;
  std::vector<std::set<Transition>> transitions;
  NodeId initial_state;
  States final_states;

 public:
  CEA(LogicalCEA&& logical_cea) {
    // clang-format off
    logical_cea = RemoveUnreachableStates()(
                  RemoveUselessStates()(
                  RemoveEpsilonTransitions()(
                  AddUniqueInitialState()(std::move(logical_cea)))));
    // clang-format on
    amount_of_states = logical_cea.amount_of_states;
    transcribe_transitions(logical_cea);

    auto initial_states_list = logical_cea.get_initial_states();
    assert(initial_states_list.size() == 1);
    initial_state = initial_states_list[0];
    final_states = logical_cea.final_states;
  }

  void add_n_states(uint64_t n) {
    amount_of_states += n;
    for (int64_t i = 0; i < n; i++) {
      transitions.push_back({});
    }
  }

  std::vector<int64_t> get_final_states() {
    std::vector<int64_t> out;
    States final_states_copy = final_states;
    int64_t current_pos = 0;
    while (final_states_copy != 0) {
      if ((final_states_copy & 1) != 0) {
        out.push_back(current_pos);
      }
      final_states_copy >>= 1;
      current_pos++;
    }
    return out;
  }

  //using Transition = std::tuple<PredicateSet, VariablesToMark, EndNodeId>;
  std::string to_string() const {
    // clang-format off
    std::string out =
      "CEA\n"
      "    Q = {0.." + std::to_string(amount_of_states - 1) + "}\n"
      "    q0 = " + std::to_string(initial_state) + "\n"
      "    F = (bitset) " + final_states.get_str(2) + "\n"
      "    Δ : {PredicateSet × Marked → FinalState}" + "\n";
    // clang-format on
    for (size_t i = 0; i < transitions.size(); i++) {
      if (transitions[i].size() != 0) out += "    Δ[" + std::to_string(i) + "]\n";
      for (const std::tuple<PredicateSet, IsMarked, NodeId>& transition : transitions[i]) {
        out += "        " + std::get<0>(transition).to_string() + ","
               + (std::get<1>(transition) ? "Marked" : "Unmarked") + ","
               + std::to_string(std::get<2>(transition)) + "\n";
      }
    }
    return out;
  }

 private:
  void transcribe_transitions(LogicalCEA& logical_cea) {
    transitions.clear();
    for (NodeId node_pos = 0; node_pos < amount_of_states; node_pos++) {
      transitions.push_back({});
      for (auto transition : logical_cea.transitions[node_pos]) {
        transitions[node_pos].insert(std::make_tuple(std::get<0>(transition),
                                                     (std::get<1>(transition) != 0),
                                                     std::get<2>(transition)));
      }
    }
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./enumeration/tecs/event.hpp>
#pragma once

#include <cassert>
#include <cstdint>
#include <ctime>
#include <string>
#include <string_view>
#include <tracy/Tracy.hpp>
#include <vector>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "core_server/internal/stream/ring_tuple_queue/value.hpp"

namespace CORE::Internal::tECS {

class Event {
 public:
  RingTupleQueue::Tuple event;
  std::vector<RingTupleQueue::SupportedTypes> schema = event.get_schema();

  Event(RingTupleQueue::Tuple event) : event(event) {}

  enum Type { INT64, DOUBLE, BOOL, STRING_VIEW, DATE };

  std::string to_string() const {
    ZoneScopedN("Internal::Event::to_string");
    std::string out = "(id: " + std::to_string(event.id()) + " attributes: [";
    for (uint64_t i = 0; i < event.size(); i++) {
      switch (schema[i]) {
        case RingTupleQueue::StructType::INT64:
          out += std::to_string(RingTupleQueue::Value<int64_t>(event[i]).get());
          break;
        case RingTupleQueue::StructType::DOUBLE:
          out += std::to_string(RingTupleQueue::Value<double>(event[i]).get());
          break;
        case RingTupleQueue::StructType::BOOL:
          out += std::to_string(RingTupleQueue::Value<bool>(event[i]).get());
          break;
        case RingTupleQueue::StructType::STRING_VIEW:
          out += RingTupleQueue::Value<std::string_view>(event[i]).get();
          break;
        case RingTupleQueue::StructType::DATE:
          out += std::to_string(RingTupleQueue::Value<std::time_t>(event[i]).get());
          break;
        default:
          assert(false && "Some Value Type was not implemented");
      }
      out += " ";
    }
    return out + "])";
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/tecs.hpp>
#pragma once

#include <atomic>
#include <cassert>
#include <cstdint>
#include <utility>
#include <vector>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "node.hpp"
#include "node_manager.hpp"
#include "time_reservator.hpp"

namespace CORE::Internal::tECS {

class tECS {
  // tECS manages nodes and union lists, by default all operations take
  // ownership of the node passed.
  using UnionList = std::vector<Node*>;

 public:
  TimeReservator* time_reservator;

 private:
  NodeManager node_manager;

 public:
  tECS(std::atomic<uint64_t>& event_time_of_expiration)
      : node_manager(MEMORY_POOL_STARTING_SIZE, event_time_of_expiration) {
    time_reservator = &node_manager.get_time_reservator();
  }

  void pin(Node* node) { node_manager.increase_ref_count(node); }

  void pin(UnionList& ulist) {
    for (auto node : ulist) {
      pin(node);
    }
  }

  /**
   * If a node is no longer used, it should be unpinned, this allows the
   * memory manager to recycle the memory allocated to it.
   */
  void unpin(Node* node) { node_manager.decrease_ref_count(node); }

  void unpin(UnionList& ulist) {
    for (auto& node : ulist) {
      unpin(node);
    }
  }

  /**
   * The bottom node, also known as the terminal node, has no children and
   * tells us that we reached the end of an output
   */
  [[nodiscard]] Node* new_bottom(RingTupleQueue::Tuple& tuple, uint64_t timestamp) {
    auto out = node_manager.alloc(tuple, timestamp);
    assert(out != nullptr);
    return out;
  }

  /**
   * Extend nodes, also known as content nodes store the opened and closed
   * variables and the position in the document that this annotation is
   * referring to.
   */
  [[nodiscard]] Node*
  new_extend(Node* node, RingTupleQueue::Tuple& tuple, uint64_t timestamp) {
    return node_manager.alloc(node, tuple, timestamp);
  }

  /**
   * Union nodes allow us to enumerate multiple outputs starting from a
   * single node.
   */
  [[nodiscard]] Node* new_union(Node* node_1, Node* node_2) {
    assert(node_1 != nullptr && node_2 != nullptr);
    assert(node_1->node_type != Node::NodeType::DEAD);
    assert(node_2->node_type != Node::NodeType::DEAD);
    assert(node_1->max() == node_2->max());
    if (!node_1->is_union()) {
      return new_direct_union(node_1, node_2);
    } else if (!node_2->is_union()) {
      return new_direct_union(node_2, node_1);
    } else {
      return create_union_of_two_union_nodes(node_1, node_2);
    }
  }

  [[nodiscard]] Node* new_direct_union(Node* node_1, Node* node_2) {
    assert(node_1 != nullptr && node_2 != nullptr);
    assert(node_1->node_type != Node::NodeType::DEAD);
    assert(node_2->node_type != Node::NodeType::DEAD);
    return node_manager.alloc(node_1, node_2);
  }

  /**
   * If the node is going to be used in another scope, it is necessary to
   * pin it so that the memory manager does not recycle its memory location.
   */
  UnionList new_ulist(Node* node) {
    assert(!node->is_union());
    pin(node);
    return {node};
  }

  /// Inserts the node in the ulist, maintaining the max-sorted invariant.
  [[nodiscard]] UnionList insert(UnionList&& ulist, Node* node) {
    assert_required_properties_of_union_list(ulist);
    assert(node->max() <= ulist[0]->max());
    if (ulist.size() == 1) {
      ulist.push_back(node);
      pin(node);
      assert_required_properties_of_union_list(ulist);
      return std::move(ulist);
    }
    // TODO: binary search would be better on large lists.
    int64_t i;
    for (i = 1; i < ulist.size(); i++) {
      if (ulist[i]->max() == node->max()) {
        Node* union_node = new_union(ulist[i], node);
        pin(union_node);
        unpin(ulist[i]);
        ulist[i] = union_node;
        break;
      }
      if (ulist[i]->max() < node->max()) {
        pin(node);
        ulist.insert(ulist.begin() + i, node);
        break;
      }
    }
    if (i == ulist.size()) {
      pin(node);
      ulist.push_back(node);
    }

    assert_required_properties_of_union_list(ulist);
    return std::move(ulist);
  }

  /*       _\|/_
           (o o)
   +----oOO-{_}-OOo---------------------------------------+
   |From the union list: n0, n1, ... nk creates this node:|
   |     u                                                |
   |    / \                                               |
   |  n0   u1                                             |
   |      /  \                                            |
   |     n1   u2                                          |
   |         /  \                                         |
   |        n2   \                                        |
   |              uk-1                                    |
   |             /   \                                    |
   |           nk-1   nk                                  |
   +-----------------------------------------------------*/
  Node* merge(UnionList& ulist) {
    assert_required_properties_of_union_list(ulist);
    Node* tail = ulist.back();
    for (auto rit = ulist.rbegin() + 1; rit != ulist.rend(); ++rit) {
      assert(*rit != nullptr && tail != nullptr);
      Node* node_1 = *rit;
      assert(node_1->node_type != Node::NodeType::DEAD);
      assert(tail->node_type != Node::NodeType::DEAD);
      tail = node_manager.alloc(node_1, tail);
    }
    assert(tail != nullptr);
    return tail;
  }

 private:
  void assert_required_properties_of_union_list(UnionList& union_list) {
    assert(union_list.size() >= 1);
    assert(union_list[0] != nullptr);
    assert(!union_list[0]->is_union());
    for (int i = 0; i < union_list.size(); i++) {
      assert(union_list[i] != nullptr);
      assert(union_list[0]->max() >= union_list[i]->max());
    }
    for (int i = 2; i < union_list.size(); i++) {
      assert(union_list[i - 1]->max() > union_list[i]->max());
    }
  }

  /*!       _\|/_
            (o o)
    +----oOO-{_}-OOo---------------------------------------+
    |           u                                          |
    |         /   \            The union of two nodes that |
    |        /    u1           are non output nodes creates|
    |       /      |\          the union that is shown on  |
    |      /       | u2        the left. If max(right(n1)) |
    |     /        |/  \       is >= than max(right(n2))   |
    |    /         |    \      then r(n1) is the left child|
    |   /         /|     \     of u2, if not, it is the    |
    |  /         / |      \    right child.                |
    | /  n1     /  |   n2  |                               |
    || /   \   /   | /    \|                               |
    |l(n1) r(n1)  l(n2)   r(n2)                            |
    +----------------------------------------------------- +
  */
  Node* create_union_of_two_union_nodes(Node* node_1, Node* node_2) {
    /// Because the creation of the union gives ownership of the nodes,
    /// the children of n1 and n2 are the ones that are referenced.
    /// n1 and n2 are not going to be used, therefore they are unpined.
    assert(node_1 != nullptr);
    assert(node_2 != nullptr);
    Node* u2 = create_first_intermediate_union_node(node_1, node_2);
    assert(u2 != nullptr);
    Node* u1 = create_second_intermediate_union_node(node_2, u2);
    assert(u1 != nullptr);
    Node* new_node = create_union_of_output_and_intermediate_node(node_1, u1);
    assert(new_node != nullptr);
    return new_node;
  }

  Node* create_first_intermediate_union_node(Node* node_1, Node* node_2) {
    assert(node_1 != nullptr);
    assert(node_2 != nullptr);
    assert(node_1->right->node_type != Node::NodeType::DEAD);
    assert(node_2->right->node_type != Node::NodeType::DEAD);
    Node* u2;
    if (node_1->max() >= node_2->max()) {
      u2 = node_manager.alloc(node_1->right, node_2->right);
    } else {
      u2 = node_manager.alloc(node_2->right, node_1->right);
    }
    assert(u2 != nullptr);
    return u2;
  }

  Node* create_second_intermediate_union_node(Node* node_2, Node* u2) {
    assert(node_2 != nullptr);
    assert(u2 != nullptr);
    assert(node_2->left != nullptr);
    assert(node_2->left->node_type != Node::NodeType::DEAD);
    assert(u2->node_type != Node::NodeType::DEAD);
    Node* u1 = node_manager.alloc(node_2->left, u2);
    assert(u1 != nullptr);
    return u1;
  }

  Node* create_union_of_output_and_intermediate_node(Node* node_1, Node* u2) {
    assert(node_1 != nullptr);
    assert(u2 != nullptr);
    assert(node_1->left != nullptr);
    assert(node_1->left->node_type != Node::NodeType::DEAD);
    assert(u2->node_type != Node::NodeType::DEAD);
    Node* new_node = node_manager.alloc(node_1->left, u2);
    assert(new_node != nullptr);
    return new_node;
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/node.hpp>
#pragma once
#include <stdint.h>

#include <cassert>
#include <cwchar>
#include <string>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"

namespace CORE::Internal::tECS {
class Node {
  friend class NodeManager;
  friend class TimeListManager;
  friend class tECS;

 private:
  enum class NodeType {
    BOTTOM,
    UNION,
    OUTPUT,
    DEAD,
    TIME_LIST_HEAD,
    TIME_LIST_TAIL,
  };
  NodeType node_type;

  Node* left = nullptr;

  union {
    Node* right = nullptr;
    RingTupleQueue::Tuple tuple;
  };

  union {
    uint64_t ref_count{0};
    Node* next_free_node;
  };

  Node* time_list_left;
  Node* time_list_right;

 public:
  uint64_t maximum_start;
  uint64_t timestamp;

  /**
   * The timestamp does not need to be the timestamp in the tuple. It
   * could be for example the stream position.
   */

  /* BOTTOM Node */
  Node(RingTupleQueue::Tuple tuple, uint64_t timestamp) {
    reset(tuple, timestamp);  //Se llama a reset para evitar repetir codigo
  }

  // TODO: Check if I really need a tuple.

  void reset(RingTupleQueue::Tuple tuple, uint64_t timestamp) {
    left = nullptr;
    this->tuple = tuple;
    this->timestamp = timestamp;
    this->node_type = NodeType::BOTTOM;
    this->maximum_start = timestamp;
    this->ref_count = 0;  // Ahora parte con ref_count 0 (lo mismo para los demas casos)
  }

  /* OUTPUT Node */
  Node(Node* node, RingTupleQueue::Tuple tuple, uint64_t timestamp) {
    assert(node != nullptr);
    reset(node, tuple,
          timestamp);  //Se llama a reset para evitar repetir codigo
  }

  void reset(Node* node, RingTupleQueue::Tuple tuple, uint64_t timestamp) {
    this->left = node;
    this->tuple = tuple;
    this->timestamp = timestamp;
    this->node_type = NodeType::OUTPUT;
    assert(left != nullptr);
    node->ref_count += 1;  // Se suma la referencia al nodo hijo para no reciclarla (como antes)
    maximum_start = left->maximum_start;
    this->ref_count = 0;
  }

  /* UNION Node */
  Node(Node* left, Node* right) { reset(left, right); }

  void reset(Node* left, Node* right) {
    this->node_type = NodeType::UNION;
    assert(left != nullptr);
    assert(right != nullptr);
    left->ref_count += 1;  // Se suma la referencia a cada hijo para no reciclarlas
    right->ref_count += 1;
    this->left = left;
    this->right = right;
    timestamp = {};  // TODO: this is not neccessary right?
    assert(this->left->maximum_start >= this->right->maximum_start);
    maximum_start = this->left->maximum_start;
    this->ref_count = 0;
  }

  /* TIME_LIST_HEAD/TAIL Nodes */
  Node(NodeType node_type) : node_type(node_type) { reset(node_type); }

  void reset(NodeType node_type) {
    assert(node_type == NodeType::TIME_LIST_HEAD || node_type == NodeType::TIME_LIST_TAIL);
    this->node_type = node_type;
    maximum_start = UINT64_MAX;
    this->ref_count = 1;  // Se mantiene en 1 dado que en teoria se ocupa siempre
  }

  bool is_union() const { return node_type == NodeType::UNION; }

  bool is_output() const { return node_type == NodeType::OUTPUT; }

  bool is_bottom() const { return node_type == NodeType::BOTTOM; }

  bool is_dead() const { return node_type == NodeType::DEAD; }

  uint64_t pos() const {
    assert(!is_union());
    return timestamp;
  }

  RingTupleQueue::Tuple get_tuple() const {
    assert(!is_union());
    return tuple;
  }

  Node* next() const {
    assert(is_output());
    assert(left != nullptr);
    return left;
  }

  Node* get_left() const {
    assert(is_union());
    return left;
  }

  Node* get_right() const {
    assert(is_union());
    return right;
  }

  uint64_t max() const { return maximum_start; }

  std::string to_string(size_t depth = 0) const {
    std::string out = "";
    for (size_t i = 0; i < depth; i++) {
      out += "    ";
    }
    if (is_bottom()) {
      out += "Bottom(" + std::to_string(tuple.id()) + ")";
    } else if (is_output()) {
      out += "Output(" + std::to_string(tuple.id()) + ")\n";
      out += left->to_string(depth + 1);
    } else {
      out += "Union\n";
      out += left->to_string(depth + 1);
      out += "\n";
      out += right->to_string(depth + 1);
    }
    return out;
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/enumerator.hpp>
#pragma once
#include <algorithm>
#include <cassert>
#include <cstdint>
#include <memory>
#include <stack>
#include <tracy/Tracy.hpp>
#include <utility>
#include <vector>

#include "complex_event.hpp"
#include "core_server/internal/evaluation/enumeration/tecs/time_reservator.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "node.hpp"
#include "tecs.hpp"

namespace CORE::Internal::tECS {

class Enumerator {
  friend class iterator;

  class iterator {
   private:
    Enumerator& enumerator;
    bool is_end;
    uint64_t current_number_result = 0;

   public:
    iterator(Enumerator& enumerator, bool is_end)
        : enumerator(enumerator), is_end(is_end) {}

    ComplexEvent operator*() { return enumerator.next(); }

    bool operator!=(const iterator& other) const { return is_end != other.is_end; }

    iterator& operator++() {
      ZoneScopedN("Internal::Enumerator::iterator::operator++");
      current_number_result++;
      if (current_number_result == enumerator.enumeration_limit
          || !enumerator.has_next()) {
        is_end = true;
      }
      return *this;
    }
  };

  std::stack<std::pair<Node*, std::vector<RingTupleQueue::Tuple>>> stack;
  uint64_t original_pos;
  uint64_t last_time_to_consider;
  std::pair<std::pair<uint64_t, uint64_t>, std::vector<RingTupleQueue::Tuple>> next_value;
  Node* original_node{nullptr};
  std::shared_ptr<tECS> tecs{nullptr};
  TimeReservator* time_reservator{nullptr};
  TimeReservator::Node* time_reserved_node{nullptr};
  int64_t enumeration_limit;

 public:
  Enumerator(Node* node,
             uint64_t original_pos,
             uint64_t time_window,
             std::shared_ptr<tECS> tecs,
             TimeReservator* time_reservator,
             int64_t enumeration_limit)
      : original_pos(original_pos),
        last_time_to_consider((original_pos < time_window) ? 0
                                                           : original_pos - time_window),
        original_node(node),
        tecs(tecs),
        time_reservator(time_reservator),
        enumeration_limit(enumeration_limit) {
    assert(time_reservator != nullptr);
    time_reserved_node = time_reservator->reserve(last_time_to_consider);
    assert(node != nullptr);
    if (node->max() >= last_time_to_consider) {
      stack.push({node, {}});
    }
  }

  /// The copy constructor is deleted so that it does not inferfere with
  /// the delete operator of the enumerator.
  Enumerator(const Enumerator&) = delete;

  /// The copy assignment is deleted so that it does not inferfere with
  /// the delete operator of the enumerator.
  Enumerator& operator=(const Enumerator&) = delete;

  // Allow move constructor
  Enumerator(Enumerator&& other) noexcept
      : stack(std::move(other.stack)),
        original_pos(other.original_pos),
        last_time_to_consider(other.last_time_to_consider),
        next_value(std::move(other.next_value)),
        original_node(other.original_node),
        tecs(other.tecs),
        time_reservator(other.time_reservator),
        time_reserved_node(other.time_reserved_node),
        enumeration_limit(other.enumeration_limit) {
    other.tecs = nullptr;
    other.time_reservator = nullptr;
    other.time_reserved_node = nullptr;
  }

  // Allow move assignment
  Enumerator& operator=(Enumerator&& other) noexcept {
    if (this != &other) {
      // cleanup();
      stack = std::move(other.stack);
      original_pos = other.original_pos;
      last_time_to_consider = other.last_time_to_consider;
      next_value = std::move(other.next_value);
      original_node = other.original_node;
      tecs = other.tecs;
      time_reservator = other.time_reservator;
      time_reserved_node = other.time_reserved_node;
      enumeration_limit = other.enumeration_limit;
      other.tecs = nullptr;
      other.time_reservator = nullptr;
      other.time_reserved_node = nullptr;
    }
    return *this;
  }

  Enumerator()
      : original_node(nullptr),
        tecs(nullptr),
        time_reservator{nullptr},
        time_reserved_node{nullptr} {}  // Empty enumerator

  ~Enumerator() {
    if (tecs != nullptr) {
      cleanup();
    }
  }

  iterator begin() { return iterator(*this, !has_next() || enumeration_limit == 0); }

  iterator end() { return iterator(*this, true); }

  void reset() {
    stack = {};
    if (original_node != nullptr && original_node->max() >= last_time_to_consider) {
      stack.push({original_node, {}});
    }
  };

 private:
  bool has_next() {
    ZoneScopedN("Internal::Enumerator::has_next");
    while (!stack.empty()) {
      Node* current_node = stack.top().first;
      std::vector<RingTupleQueue::Tuple> tuples = stack.top().second;
      stack.pop();
      while (true) {
        if (current_node->is_bottom()) {
          next_value = {{current_node->pos(), original_pos}, tuples};
          return true;
        } else if (current_node->is_output()) {
          tuples.push_back(current_node->get_tuple());
          current_node = current_node->next();
        } else if (current_node->is_union()) {
          if (current_node->get_right()->max() >= last_time_to_consider) {
            stack.push({current_node->get_right(), tuples});
          }
          current_node = current_node->get_left();
        }
      }
    }
    return false;
  }

  /// It requires has_next to be evaluated before.
  ComplexEvent next() {
    ZoneScopedN("Internal::Enumerator::next");
    std::reverse(next_value.second.begin(), next_value.second.end());
    return ComplexEvent(next_value);
  }

  inline void cleanup() {
    if (tecs != nullptr) {
      assert(tecs != nullptr);
      tecs->unpin(original_node);
      assert(time_reservator != nullptr);
      assert(time_reserved_node != nullptr);
      time_reservator->remove_node(time_reserved_node);
      time_reserved_node = nullptr;
      tecs = nullptr;
    }
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/time_reservator.hpp>
#pragma once

#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <iostream>
#include <memory>
#include <mutex>
#include <utility>

namespace CORE::Internal::tECS {

class TimeReservator {
 public:
  class Node {
    friend class TimeReservator;
    std::unique_ptr<Node> right{nullptr};
    Node* left{nullptr};
    uint64_t time_reservation;

   public:
    Node(uint64_t time_reservation) : time_reservation(time_reservation) {}
  };

 private:
  std::unique_ptr<Node> head;
  Node* tail{nullptr};
  std::mutex mtx;

 public:
  TimeReservator() : head(std::make_unique<Node>(UINT64_MAX)) {
    head->right = std::make_unique<Node>(UINT64_MAX);
    head->right->left = head.get();
    tail = head->right.get();
    assert(list_is_well_formed());
  }

  TimeReservator(TimeReservator&& other) noexcept {
    std::lock_guard<std::mutex> lock(mtx);
    other.head = std::move(head);
    other.tail = tail;
  }

  Node* reserve(uint64_t time) {
    auto new_node = std::make_unique<Node>(time);

    std::lock_guard<std::mutex> lock(mtx);
    assert(list_is_well_formed());
    new_node->right = std::move(head->right);
    assert(new_node->right != nullptr);
    new_node->right->left = new_node.get();

    new_node->left = head.get();
    head->right = std::move(new_node);
    auto out = head->right.get();
    assert(list_is_well_formed());
    assert(list_contains(out));
    return out;
  }

  uint64_t get_smallest_reserved_time() {
    std::lock_guard<std::mutex> lock(mtx);
    return tail->left->time_reservation;
  }

  void remove_node(Node* node) {
    std::lock_guard<std::mutex> lock(mtx);
    assert(list_is_well_formed());
    assert(list_contains(node));
    node->right->left = node->left;
    node->left->right = std::move(node->right);
    assert(list_is_well_formed());
  }

 private:
  bool list_is_well_formed() {
    if (head == nullptr || tail == nullptr) {
      std::cout << "Head or tail is nullptr" << std::endl;
      return false;
    }

    Node* current = head.get();
    Node* previous = nullptr;

    // Loop through the list from head to tail.
    while (current != nullptr) {
      if (current->right == nullptr && current != tail) {
        std::cout << "Right of a non-tail node is nullptr" << std::endl;
        return false;
      }

      if (current->left == nullptr && current != head.get()) {
        std::cout << "Left of a non-head node is nullptr" << std::endl;
        return false;
      }

      if (current->right != nullptr && current->right->left != current) {
        std::cout << "Right node's left does not point back to node" << std::endl;
        return false;
      }

      if (current->left != nullptr && current->left->right.get() != current) {
        std::cout << "Left node's right does not point back to node" << std::endl;
        return false;
      }

      previous = current;
      current = current->right.get();
    }

    if (previous != tail) {
      std::cout << "Did not reach tail starting from head" << std::endl;
      return false;
    }

    return true;
  }

  bool list_contains(Node* node) {
    Node* current = head.get();
    while (current != nullptr) {
      if (current == node) {
        return true;
      }
      current = current->right.get();
    }
    return false;
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/node_manager.hpp>
#pragma once

#define QUILL_ROOT_LOGGER_ONLY
#include <quill/Quill.h>  // NOLINT
#include <quill/detail/LogMacros.h>

#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <sstream>
#include <string>

#include "core_server/internal/evaluation/enumeration/tecs/time_reservator.hpp"
#include "core_server/internal/evaluation/minipool/minipool.hpp"
#include "node.hpp"
#include "shared/logging/setup.hpp"
#include "time_list_manager.hpp"

namespace CORE::Internal::tECS {

const size_t MEMORY_POOL_STARTING_SIZE = 2048;

/**
 * The Node Manager class stores the pointers to all allocated
 * ECSNode's. When an ECSNode is no longer used, i.e, when the amount
 * of references to it has become 0, that memory is available to be recycled.
 */
class NodeManager {
  typedef MiniPool::MiniPool<Node> NodePool;

 public:
  size_t amount_of_nodes_used{0};
  size_t amount_of_recycled_nodes{0};
  std::atomic<uint64_t>& expiration_time;

 private:
  NodePool* minipool_head = nullptr;
  Node* recyclable_node_head = nullptr;
  TimeListManager time_list_manager;

 public:
  NodeManager(size_t starting_size, std::atomic<uint64_t>& event_time_of_expiration)
      : minipool_head(new NodePool(starting_size)),
        recyclable_node_head(nullptr),
        time_list_manager(*this),
        expiration_time(event_time_of_expiration) {}

  NodeManager(NodeManager&& other) = default;

  ~NodeManager() {
    for (NodePool* mp = minipool_head; mp != nullptr;) {
      NodePool* next = mp->next();
      delete mp;
      mp = next;
    }
  }

  template <class... Args>
  Node* alloc(Args&&... args) {
    LOG_L3_BACKTRACE(
      "Adding node to node_manager, currently at {} nodes used with {} nodes recycled",
      amount_of_nodes_used,
      amount_of_recycled_nodes);
    Node* out = get_node_to_recycle_or_increase_mempool_size_if_necessary();
    if (out != nullptr) {
      out->reset(std::forward<Args>(args)...);
    } else {
      out = allocate_a_new_node(std::forward<Args>(args)...);
    }
    time_list_manager.add_node(out);
    return out;
  }

  size_t amount_of_nodes_allocated() const {
    size_t amount = 0;
    for (NodePool* mpool = minipool_head; mpool != nullptr; mpool = mpool->prev())
      amount += mpool->capacity();
    return amount;
  }

  void increase_ref_count(Node* node) { node->ref_count++; }

  void decrease_ref_count(Node* node) {
    assert(node != nullptr);
    node->ref_count--;
    try_to_mark_node_as_unused(node);
  }

  void mark_as_dead(Node* node) {
    assert(node != nullptr);
    assert(node->node_type != Node::NodeType::DEAD);
    switch (node->node_type) {
      case Node::NodeType::UNION:
        decrease_ref_count(node->right);
        node->right = nullptr;
        [[fallthrough]];
      case Node::NodeType::OUTPUT:
        decrease_ref_count(node->left);
        node->left = nullptr;
        [[fallthrough]];
      default:
        node->node_type = Node::NodeType::DEAD;
    }
  }

  size_t get_amount_of_nodes_used() const { return amount_of_nodes_used; }

  TimeReservator& get_time_reservator() {
    return time_list_manager.get_time_reservator();
  }

 private:
  Node* get_node_to_recycle_or_increase_mempool_size_if_necessary() {
    if (!minipool_head->is_full()) {
      return nullptr;
    }
    if (recyclable_node_head == nullptr) {
      if (time_list_manager.remove_a_dead_node_if_possible(expiration_time.load())) {
        while (time_list_manager.remove_a_dead_node_if_possible(expiration_time.load()));
        if (recyclable_node_head != nullptr) {
          return get_node_to_recycle();
        }
      };
      LOG_DEBUG("Not enough memory to allocate node for TECS");
      increase_mempool_size();
      return nullptr;
    }
    return get_node_to_recycle();
  }

  void increase_mempool_size() {
    LOG_DEBUG("Increasing size of memory pool");
    NodePool* new_minipool = new NodePool(minipool_head->size() * 2);
    minipool_head->set_next(new_minipool);
    new_minipool->set_prev(minipool_head);

    minipool_head = new_minipool;
  }

  Node* get_node_to_recycle() {
    Node* node_to_recycle = recyclable_node_head;
    advance_recyclable_nodes_list_head();
    time_list_manager.remove_node(node_to_recycle);
    if (node_to_recycle->is_union()) {
      decrease_ref_count(node_to_recycle->left);
      decrease_ref_count(node_to_recycle->right);
    } else if (node_to_recycle->is_output()) {
      decrease_ref_count(node_to_recycle->left);
    } else {
      assert(node_to_recycle->is_bottom() || node_to_recycle->is_dead());
    }
    return node_to_recycle;
  }

  void advance_recyclable_nodes_list_head() {
    recyclable_node_head = recyclable_node_head->next_free_node;
    ++amount_of_recycled_nodes;
  }

  template <class... Args>
  Node* allocate_a_new_node(Args&&... args) {
    ++amount_of_nodes_used;
    return minipool_head->alloc(std::forward<Args>(args)...);
  }

  void try_to_mark_node_as_unused(Node* node) {
    if (node->ref_count == 0) {
      add_to_list_of_free_memory(node);
    }
  }

  void add_to_list_of_free_memory(Node* node) {
    node->next_free_node = recyclable_node_head;
    recyclable_node_head = node;
  }

 private:
  /// For debugging.
  std::string print_free_node_list() {
    std::string out;
    out += "Free memory list: ";
    for (Node* node = recyclable_node_head; node != nullptr; node = node->next_free_node) {
      // Transform the node pointer to string
      std::stringstream ss;
      ss << node;
      std::string node_as_string = ss.str();
      out += node_as_string;
      out += "-> ";
    }
    out += "\n";
    return out;
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/complex_event.hpp>
#pragma once

#include <cstdint>
#include <string>
#include <tracy/Tracy.hpp>
#include <utility>
#include <vector>

#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "event.hpp"

namespace CORE::Internal::tECS {

class ComplexEvent {
 public:
  uint64_t start;
  uint64_t end;
  std::vector<RingTupleQueue::Tuple> event_tuples;
  std::vector<Event> events;

  ComplexEvent(std::pair<std::pair<uint64_t, uint64_t>, std::vector<RingTupleQueue::Tuple>>
                 complex_event)
      : start(complex_event.first.first),
        end(complex_event.first.second),
        event_tuples(complex_event.second) {}

  template <bool event_info>
  std::string to_string() const {
    ZoneScopedN("Internal::ComplexEvent::to_string");
    std::string out = "[" + std::to_string(start) + "," + std::to_string(end) + "], (";
    if constexpr (event_info) {
      for (const RingTupleQueue::Tuple& event_tuple : event_tuples) {
        out += Event(event_tuple).to_string() + " ";
      }
    }
    return out + ")";
  }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/time_list_manager.cpp>
#include "time_list_manager.hpp"

#include <algorithm>
#include <cassert>
#include <cstdint>
#include <memory>

#include "core_server/internal/evaluation/enumeration/tecs/node.hpp"
#include "node_manager.hpp"

namespace CORE::Internal::tECS {

/**
 * The Node Manager class stores the pointers to all allocated
 * ECSNode's. When an ECSNode is no longer used, i.e, when the amount
 * of references to it has become 0, that memory is available to be recycled.
 */

TimeListManager::TimeListManager(NodeManager& node_manager)
    : node_manager(node_manager),
      head(std::make_unique<Node>(Node::NodeType::TIME_LIST_HEAD)),
      tail(std::make_unique<Node>(Node::NodeType::TIME_LIST_TAIL)),
      time_reservator() {
  head->time_list_left = head.get();
  head->time_list_right = tail.get();
  tail->time_list_left = head.get();
  tail->time_list_right = tail.get();
}

void TimeListManager::add_node(Node* node) {
  // HEAD <-> previous_right               <- now
  // HEAD <-> node <-> previous_right      <- wanted
  Node* previous_right = head->time_list_right;

  head->time_list_right = node;
  node->time_list_left = head.get();

  node->time_list_right = previous_right;
  previous_right->time_list_left = node;
}

bool TimeListManager::remove_a_dead_node_if_possible(uint64_t maximum_start_limit) {
  uint64_t limit = std::min(maximum_start_limit,
                            time_reservator.get_smallest_reserved_time());
  if (tail->time_list_left->maximum_start < limit) {
    remove_node(tail->time_list_left);
    return true;
  }
  return false;
}

void TimeListManager::remove_node(Node* node) {
  assert(node != nullptr);
  if (node->time_list_left != nullptr) {
    assert(node->time_list_right != nullptr);

    // Prev <-> node <-> Post          <- current
    // Prev <-> Post                   <- wanted
    Node* prev = node->time_list_left;
    Node* post = node->time_list_right;
    node->time_list_left = nullptr;
    node->time_list_right = nullptr;

    prev->time_list_right = post;
    post->time_list_left = prev;

    node_manager.mark_as_dead(node);
  }
}
}  // namespace CORE::Internal::tECS
</file>
<file ./enumeration/tecs/time_list_manager.hpp>
#pragma once

#include <cstdint>
#include <cstdlib>
#include <memory>

#include "node.hpp"
#include "time_reservator.hpp"

namespace CORE::Internal::tECS {

/**
 * The Node Manager class stores the pointers to all allocated
 * ECSNode's. When an ECSNode is no longer used, i.e, when the amount
 * of references to it has become 0, that memory is available to be recycled.
 */

class NodeManager;

class TimeListManager {
  NodeManager& node_manager;
  TimeReservator time_reservator;
  std::unique_ptr<Node> head;
  std::unique_ptr<Node> tail;

 public:
  TimeListManager(NodeManager& node_manager);

  void add_node(Node* node);
  bool remove_a_dead_node_if_possible(uint64_t maximum_start_limit);
  void remove_node(Node* node);

  TimeReservator& get_time_reservator() { return time_reservator; }
};
}  // namespace CORE::Internal::tECS
</file>
<file ./predicate_evaluator.hpp>
#pragma once

#include <gmpxx.h>

#include <cstddef>
#include <memory>
#include <string>
#include <tracy/Tracy.hpp>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/physical_predicate/physical_predicate.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "shared/datatypes/eventWrapper.hpp"

namespace CORE::Internal::Evaluation {

struct PredicateEvaluator {
  std::vector<std::shared_ptr<CEA::PhysicalPredicate>> predicates;

  PredicateEvaluator(
    std::vector<std::unique_ptr<CEA::PhysicalPredicate>>&& unique_predicates) {
    predicates.reserve(unique_predicates.size());
    for (auto& unique_pred : unique_predicates) {
      predicates.push_back(std::move(unique_pred));
    }
  }

  mpz_class operator()(RingTupleQueue::Tuple& tuple, Types::EventWrapper& event) {
    ZoneScopedN("PredicateEvaluator::operator()");
    mpz_class out_tuple = 0;
    mpz_class one = 1;
    for (size_t i = 0; i < predicates.size(); i++) {
      if ((*predicates[i])(tuple)) {
        out_tuple |= one << i;
      }
    }
    for (size_t i = 0; i < predicates.size(); i++) {
      if ((*predicates[i])(event)) {
        out_tuple |= one << i;
      }
    }
    return out_tuple;
  }

  std::string to_string() const {
    std::string out = "Physical predicates:\n";
    for (auto& pred : predicates) {
      out += "    " + pred->to_string() + "\n";
    }
    return out;
  }
};

}  // namespace CORE::Internal::Evaluation
</file>
<file ./det_cea/state.hpp>
#pragma once
#include <gmpxx.h>

#include <cassert>
#include <cstdint>
#include <map>
#include <utility>

#include "core_server/internal/evaluation/cea/cea.hpp"

namespace CORE::Internal::CEA::Det {

class State {
  friend class StateManager;

 private:
  struct StatesData {
    uint64_t marked_state_id;
    State* marked_state;
    uint64_t unmarked_state_id;
    State* unmarked_state;

    bool is_consistent() {
      assert(marked_state != nullptr && unmarked_state != nullptr);
      return (marked_state_id == marked_state->id)
             && (unmarked_state_id == unmarked_state->id);
    }
  };

 public:
  struct States {
    State* marked_state;
    State* unmarked_state;
  };

  uint64_t id;
  mpz_class states;
  // The id is stored in the transitions because in the future we might
  // want to remove some states. And to remove them we can
  CEA& cea;
  bool is_final;
  bool is_empty;

  State* prev_evictable_state = nullptr;
  State* next_evictable_state = nullptr;

 private:
  inline static uint64_t IdCounter = 0;
  uint64_t ref_count = 0;
  std::map<mpz_class, StatesData> transitions;

 public:
  State(mpz_class states, CEA& cea)
      : id(IdCounter++),
        states(states),
        cea(cea),
        is_final((states & cea.final_states) != 0),
        is_empty(states == 0) {}

  void reset(mpz_class states, CEA& cea) {
    this->id = IdCounter++;
    this->states = states;
    this->cea = cea;
    this->ref_count = 0;
    is_final = (states & cea.final_states) != 0;
    is_empty = states == 0;
    transitions.clear();
  }

  void pin() { ref_count += 1; }

  void unpin() {
    assert(ref_count != 0);
    ref_count -= 1;
  }

  States next(mpz_class evaluation, uint64_t& n_hits) {
    assert(next_evictable_state == nullptr && prev_evictable_state == nullptr);
    auto it = transitions.find(evaluation);
    if (it != transitions.end()) {
      StatesData states_data = it->second;
      if (!states_data.is_consistent()) {
        transitions.erase(it);
      } else {
        n_hits++;
        return {states_data.marked_state, states_data.unmarked_state};
      }
    }
    return {nullptr, nullptr};
  }

  void add_transition(mpz_class evaluation, States next_states) {
    assert(!transitions.contains(evaluation));
    assert(next_states.unmarked_state != nullptr && next_states.marked_state != nullptr);
    transitions.insert(std::make_pair(evaluation,
                                      StatesData{next_states.marked_state->id,
                                                 next_states.marked_state,
                                                 next_states.unmarked_state->id,
                                                 next_states.unmarked_state}));
  }

  bool is_evictable() { return ref_count == 0; }

  void set_evictable(State* const tail_evictable_state) {
    assert(next_evictable_state == nullptr && prev_evictable_state == nullptr);
    next_evictable_state = tail_evictable_state;
  }

  void unset_evictable() {
    if (next_evictable_state != nullptr) {
      next_evictable_state->prev_evictable_state = prev_evictable_state;
    }
    if (prev_evictable_state != nullptr) {
      prev_evictable_state->next_evictable_state = next_evictable_state;
    }
    next_evictable_state = nullptr;
    prev_evictable_state = nullptr;
  }
};
}  // namespace CORE::Internal::CEA::Det
</file>
<file ./det_cea/det_cea.hpp>
#pragma once
#include <gmpxx.h>

#include <cassert>
#include <cstdint>
#include <string>
#include <tracy/Tracy.hpp>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/cea/cea.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"
#include "state.hpp"
#include "state_manager.hpp"

namespace CORE::Internal::CEA {
class DetCEA {
  using State = Det::State;
  using States = Det::State::States;
  using StateManager = Det::StateManager;

 public:
  State* initial_state;

 private:
  CEA cea;
  uint64_t n_nexts = 0;
  uint64_t n_hits = 0;

 public:
  StateManager state_manager;

  DetCEA(CEA&& cea) : cea(cea), state_manager() {
    mpz_class initial_bitset_1 = mpz_class(1) << cea.initial_state;
    State* initial_state = state_manager.create_or_return_existing_state(initial_bitset_1,
                                                                         cea);
    this->initial_state = initial_state;
    state_manager.pin_state(this->initial_state);
  }

  // DetCEA(const DetCEA& other) : cea(other.cea), state_manager() {
  //   mpz_class initial_bitset_1 = mpz_class(1) << cea.initial_state;
  //   State* initial_state = state_manager.create_or_return_existing_state(initial_bitset_1,
  //                                                                        cea);
  //   this->initial_state = initial_state;
  //   this->initial_state->pin();
  // }

  States next(State* state, mpz_class evaluation, const uint64_t& current_iteration) {
    ZoneScopedN("DetCEA::next");
    assert(state != nullptr);
    n_nexts++;
    auto next_states = state->next(evaluation, n_hits);  // memoized
    if (next_states.marked_state == nullptr || next_states.unmarked_state == nullptr) {
      next_states = compute_next_states(state, evaluation, current_iteration);
      state->add_transition(evaluation, next_states);
    }
    return next_states;
  }

  std::string to_string() {
    std::string out = "";
    out += "Initial state: " + initial_state->states.get_str(2) + "\n";
    out += "State manager:\n";
    out += state_manager.to_string();
    return out;
  }

 private:
  States compute_next_states(State* state,
                             mpz_class& evaluation,
                             const uint64_t& current_iteration) {
    auto computed_bitsets = compute_next_bitsets(state, evaluation);
    mpz_class marked_bitset = computed_bitsets.first;
    mpz_class unmarked_bitset = computed_bitsets.second;
    State* marked_state = state_manager.create_or_return_existing_state(marked_bitset,
                                                                        cea);
    State* unmarked_state = state_manager.create_or_return_existing_state(unmarked_bitset,
                                                                          cea);
    return {marked_state, unmarked_state};
  }

  std::pair<mpz_class, mpz_class>
  compute_next_bitsets(State* state, mpz_class evaluation) {
    assert(state != nullptr);
    // TODO: State is not nullptr but is giving a segfault.
    auto states_bitset = state->states;
    auto states_vector = get_states_from_mpz_class(state->states);
    mpz_class new_marked_states = 0;
    mpz_class new_unmarked_states = 0;
    for (uint64_t state : states_vector) {
      for (auto transition : cea.transitions[state]) {
        PredicateSet& predicate = std::get<0>(transition);
        if (predicate.is_satisfied_by(evaluation)) {
          bool is_marked = std::get<1>(transition);
          uint64_t target_node = std::get<2>(transition);
          if (is_marked) {
            new_marked_states |= mpz_class(1) << target_node;
          } else {
            new_unmarked_states |= mpz_class(1) << target_node;
          }
        }
      }
    }
    return {new_marked_states, new_unmarked_states};
  }

  std::vector<uint64_t> get_states_from_mpz_class(mpz_class states) {
    std::vector<uint64_t> out;
    int64_t current_pos = 0;
    while (states != 0) {
      if ((states & 1) != 0) {
        out.push_back(current_pos);
      }
      states >>= 1;
      current_pos++;
    }
    return out;
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./det_cea/state_manager.hpp>
#pragma once

#define QUILL_ROOT_LOGGER_ONLY
#include <gmpxx.h>
#include <quill/Quill.h>  // NOLINT
#include <quill/detail/LogMacros.h>

#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <map>
#include <string>
#include <vector>

#include "core_server/internal/evaluation/cea/cea.hpp"
#include "core_server/internal/evaluation/minipool/minipool.hpp"
#include "shared/logging/setup.hpp"
#include "state.hpp"

namespace CORE::Internal::CEA::Det {

const size_t STATE_MANAGER_STARTING_SIZE = 1;
const size_t STATE_MANAGER_MAX_SIZE = 4;

/**
 * The Node Manager class stores the pointers to all allocated
 * state nodes. When we need a state node, but we are out of memory,
 * we remove one of the existing nodes and reuse it.
 */
class StateManager {
  using StatePool = MiniPool::MiniPool<State>;
  using States = Det::State::States;

 private:
  size_t amount_of_used_states{0};
  size_t amount_of_allowed_states;
  StatePool* minipool_head = nullptr;
  State* evictable_state_head = nullptr;
  State* evictable_state_tail = nullptr;
  std::vector<State*> states;
  std::map<mpz_class, uint64_t> states_bitset_to_index;

 public:
  StateManager()
      : minipool_head(new StatePool(STATE_MANAGER_STARTING_SIZE)),
        amount_of_allowed_states(STATE_MANAGER_MAX_SIZE) {}

  StateManager(StateManager&& other) noexcept
      : amount_of_used_states(other.amount_of_used_states),
        amount_of_allowed_states(other.amount_of_allowed_states),
        minipool_head(other.minipool_head) {
    other.minipool_head = nullptr;
  }

  ~StateManager() {
    for (StatePool* mp = minipool_head; mp != nullptr;) {
      StatePool* next = mp->prev();
      delete mp;
      mp = next;
    }
  }

  void pin_state(State* const state) {
    state->pin();
    unset_evictable_state(state);
  }

  void unpin_states(const std::vector<State*>& evicted_states) {
    for (State* state : evicted_states) {
      state->unpin();
      if (state->is_evictable()) {
        set_evictable_state(state);
      }
    }
  }

  std::string to_string() {
    std::string out = "";
    out += "Number of initialized states: " + std::to_string(states.size()) + "\n";
    out += "Initialized States:\n";
    for (auto& state : states) {
      out += state->states.get_str(2);
    }
    return out;
  }

  State* create_or_return_existing_state(mpz_class bitset, CEA& cea) {
    auto it = states_bitset_to_index.find(bitset);
    if (it != states_bitset_to_index.end()) {
      assert(it->second < states.size());
      return states[it->second];
    } else {
      State* state = alloc(bitset, cea);
      return state;
    }
  }

 private:
  template <class... Args>
  State* alloc(Args&&... args) {
    LOG_L3_BACKTRACE(
      "Adding state to state_manager, currently at {} states used with {} states "
      "allocated",
      amount_of_used_states,
      amount_of_allowed_states);
    State* new_state;
    new_state = allocate_state(std::forward<Args>(args)...);
    if (new_state == nullptr) {
      // Not enough memory, try to evict a state.
      new_state = evictable_state_head;
      if (new_state != nullptr) {
        // Successfully evicted a state, reset it and return it.
        reset_state(new_state, std::forward<Args>(args)...);
      } else {
        // Not enough memory, force increase the memory pool.
        LOG_DEBUG("Not enough memory to allocate DetCEA state");
        size_t amount_force_added_states = increase_mempool_size();
        amount_of_allowed_states += amount_force_added_states;
        new_state = allocate_state(std::forward<Args>(args)...);
      }
    } else {
    }
    assert(new_state != nullptr);
    return new_state;
  }

  template <class... Args>
  State* allocate_state(Args&&... args) {
    if (amount_of_used_states < amount_of_allowed_states) {
      if (minipool_head->is_full()) {
        increase_mempool_size();
      }
      amount_of_used_states++;
      State* state = minipool_head->alloc(std::forward<Args>(args)...);
      // Add the state to the list of states as is a new state.
      states.push_back(state);
      states_bitset_to_index[state->states] = states.size() - 1;
      return state;
    } else {
      return nullptr;
    }
  }

  /**
   * Increase the size of the memory pool by a factor of 2.
   *
   * @return The new size of the memory pool.
   */
  size_t increase_mempool_size() {
    LOG_DEBUG("Increasing size of memory pool");
    size_t new_size = minipool_head->size() * 2;
    StatePool* new_minipool = new StatePool(new_size);
    minipool_head->set_next(new_minipool);
    new_minipool->set_prev(minipool_head);

    minipool_head = new_minipool;

    return new_size;
  }

  void set_evictable_state(State* const& state) {
    assert(state->is_evictable());
    assert_state_list_consistency();
    if (evictable_state_head == nullptr) {
      evictable_state_head = state;
    }
    if (evictable_state_tail != nullptr) {
      evictable_state_tail->prev_evictable_state = state;
    }
    state->set_evictable(evictable_state_tail);
    evictable_state_tail = state;
    if (this->evictable_state_head == nullptr) {
      this->evictable_state_head = state;
    }
    assert_state_list_consistency();
  }

  void unset_evictable_state(State* const& state) {
    assert_state_list_consistency();
    if (evictable_state_head == state) {
      evictable_state_head = state->prev_evictable_state;
    }
    if (evictable_state_tail == state) {
      evictable_state_tail = state->next_evictable_state;
    }
    state->unset_evictable();
    assert_state_list_consistency();
  }

  inline void assert_state_list_consistency() {
    // Check that either both are nullptr or both are not nullptr and evicted
    assert((evictable_state_head == nullptr && evictable_state_tail == nullptr)
           || (evictable_state_head != nullptr && evictable_state_tail != nullptr));

    assert(amount_of_used_states <= amount_of_allowed_states);

    State* state = evictable_state_head;
#ifdef CORE_DEBUG
    while (state != nullptr) {
      if (state->prev_evictable_state != nullptr) {
        assert(state->prev_evictable_state->next_evictable_state == state);
      }
      if (state->next_evictable_state != nullptr) {
        assert(state->next_evictable_state->prev_evictable_state == state);
      }
      if (state->prev_evictable_state == nullptr) {
        assert(state == evictable_state_tail);
      }
      state = state->prev_evictable_state;
    }
#endif
  }

  template <class... Args>
  void reset_state(State* const& state, Args&&... args) {
    mpz_class old_states = state->states;
    unset_evictable_state(state);
    state->reset(std::forward<Args>(args)...);
    states_bitset_to_index[state->states] = states_bitset_to_index[old_states];
    states_bitset_to_index.erase(old_states);
  }
};
}  // namespace CORE::Internal::CEA::Det
</file>
<file ./logical_cea/logical_cea.hpp>
#pragma once

#include <gmpxx.h>

#include <cstddef>
#include <cstdint>
#include <map>
#include <set>
#include <stdexcept>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#include "core_server/internal/coordination/query_catalog.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"
#include "shared/datatypes/aliases/event_type_id.hpp"
#include "shared/datatypes/aliases/stream_type_id.hpp"

namespace CORE::Internal::CEA {
struct LogicalCEA {
  /**
   * To obtain a LogicalCEA a string query is transformed into an
   * internal structure called Query, then the query's formula is
   * transformed to this LogicalCEA. Later on this LogicalCEA is
   * transformed into a CEA and this is used in the DetCEA.
   */

  using StreamName = std::string;
  using EventName = std::string;

 public:
  using VariablesToMark = mpz_class;
  using NodeId = uint64_t;
  using Transition = std::tuple<PredicateSet, VariablesToMark, NodeId>;
  using States = mpz_class;

  // transitions[i] = all transitions of node i.
  std::vector<std::vector<Transition>> transitions;
  std::vector<std::set<NodeId>> epsilon_transitions;
  States initial_states;
  States final_states;
  uint64_t amount_of_states;

 public:
  LogicalCEA(uint64_t amount_of_states) : amount_of_states(amount_of_states) {
    for (int i = 0; i < amount_of_states; i++) {
      transitions.push_back({});
      epsilon_transitions.push_back({});
    }
  }

  LogicalCEA(const LogicalCEA& other)
      : amount_of_states(other.amount_of_states),
        transitions(other.transitions),
        epsilon_transitions(other.epsilon_transitions),
        initial_states(other.initial_states),
        final_states(other.final_states) {}

  static LogicalCEA
  atomic_cea(const QueryCatalog& query_catalog,
             const std::map<std::pair<StreamName, EventName>, uint64_t>& stream_event_to_id,
             const StreamName stream_name,
             const EventName event_name) {
    auto atomic_cea = LogicalCEA(2);
    std::size_t number_of_streams = query_catalog.number_of_streams();
    Types::StreamTypeId query_stream_id = query_catalog.get_query_stream_id_from_stream_name(
      stream_name);
    Types::EventNameTypeId
      query_event_name_id = query_catalog.get_query_event_name_id_from_event_name(
        event_name);

    mpz_class stream_predicate_position = mpz_class(1) << query_stream_id;
    mpz_class event_name_predicate_position = mpz_class(1)
                                              << (number_of_streams + query_event_name_id);

    mpz_class expected_eval = stream_predicate_position | event_name_predicate_position;
    mpz_class predicate_mask = expected_eval;

    auto stream_event_id_iter = stream_event_to_id.find({stream_name, event_name});
    uint64_t stream_event_id = (stream_event_id_iter != stream_event_to_id.end())
                                 ? stream_event_id_iter->second
                                 : throw std::logic_error(
                                     "Stream/Event name combination not found");

    VariablesToMark stream_event_mark = mpz_class(1) << stream_event_id;
    VariablesToMark event_mark = mpz_class(1)
                                 << (stream_event_to_id.size() + query_event_name_id);

    VariablesToMark mark = stream_event_mark | event_mark;

    atomic_cea.transitions[0].push_back(
      std::make_tuple(PredicateSet(expected_eval, predicate_mask), mark, 1));

    atomic_cea.initial_states = mpz_class(1) << 0;
    atomic_cea.final_states = mpz_class(1) << 1;

    return atomic_cea;
  }

  static LogicalCEA
  atomic_cea(const QueryCatalog& query_catalog,
             const std::map<std::pair<StreamName, EventName>, uint64_t>& stream_event_to_id,
             const EventName event_name) {
    auto atomic_cea = LogicalCEA(2);
    std::size_t number_of_streams = query_catalog.number_of_streams();
    Types::EventNameTypeId
      query_event_name_id = query_catalog.get_query_event_name_id_from_event_name(
        event_name);

    mpz_class event_name_predicate_position = mpz_class(1)
                                              << (number_of_streams + query_event_name_id);

    mpz_class expected_eval = event_name_predicate_position;
    mpz_class predicate_mask = expected_eval;

    VariablesToMark event_mark = mpz_class(1)
                                 << (stream_event_to_id.size() + query_event_name_id);

    for (auto&& [current_stream_event_name, current_stream_event_id] :
         stream_event_to_id) {
      auto&& [current_stream_name, current_event_name] = current_stream_event_name;
      if (current_event_name == event_name) {
        // FIX: This doesn't make any sense, should fix
        // VariablesToMark current_stream_event_mark = mpz_class(1)
        //                                             << current_stream_event_id;
        VariablesToMark mark = event_mark;
        atomic_cea.transitions[0].push_back(
          std::make_tuple(PredicateSet(expected_eval, predicate_mask), mark, 1));
      }
    }

    atomic_cea.initial_states = mpz_class(1) << 0;
    atomic_cea.final_states = mpz_class(1) << 1;
    return atomic_cea;
  }

  void add_n_states(uint64_t n) {
    amount_of_states += n;
    for (int64_t i = 0; i < n; i++) {
      transitions.push_back({});
      epsilon_transitions.push_back({});
    }
  }

  std::vector<uint64_t> get_initial_states() {
    std::vector<uint64_t> out;
    States initial_states_copy = initial_states;
    int64_t current_pos = 0;
    while (initial_states_copy != 0) {
      if ((initial_states_copy & 1) != 0) {
        out.push_back(current_pos);
      }
      initial_states_copy >>= 1;
      current_pos++;
    }
    return out;
  }

  std::vector<uint64_t> get_final_states() {
    std::vector<uint64_t> out;
    States final_states_copy = final_states;
    int64_t current_pos = 0;
    while (final_states_copy != 0) {
      if ((final_states_copy & 1) != 0) {
        out.push_back(current_pos);
      }
      final_states_copy >>= 1;
      current_pos++;
    }
    return out;
  }

  //using Transition = std::tuple<PredicateSet, VariablesToMark, EndNodeId>;
  std::string to_string() const {
    // clang-format off
    std::string out =
      "LogicalCEA\n"
      "    Q = {0.." + std::to_string(amount_of_states - 1) + "}\n"
      "    I = (bitset) " + initial_states.get_str(2) + "\n"
      "    F = (bitset) " + final_states.get_str(2) + "\n"
      "    Δ : [PredicateSet × (bitset) VariablesToMark → FinalState]" + "\n";
    // clang-format on
    for (size_t i = 0; i < transitions.size(); i++) {
      if (transitions[i].size() != 0) out += "    Δ[" + std::to_string(i) + "]:\n";
      for (const std::tuple<PredicateSet, VariablesToMark, NodeId>& transition :
           transitions[i]) {
        out += "        " + std::get<0>(transition).to_string() + ",0xb"
               + std::get<1>(transition).get_str(2) + "→"
               + std::to_string(std::get<2>(transition)) + "\n";
      }
    }
    out += "    Δε: [NodeId]:\n";
    for (size_t i = 0; i < epsilon_transitions.size(); i++) {
      for (const NodeId& end_node : epsilon_transitions[i]) {
        out += "        " + std::to_string(i) + "→ " + std::to_string(end_node) + "\n";
      }
    }

    return out;
  }

  std::string to_string_visualization() const {
    std::string out = "";
    std::string initial_states_string = initial_states.get_str(2);
    std::string final_states_string = final_states.get_str(2);

    for (int i = 0; i < initial_states_string.length(); ++i) {
      if (initial_states_string[initial_states_string.length() - i - 1] == '1') {
        out += "i " + std::to_string(i) + "\n";
      }
    }
    for (int i = 0; i < final_states_string.length(); ++i) {
      if (final_states_string[final_states_string.length() - i - 1] == '1') {
        out += "f " + std::to_string(i) + "\n";
      }
    }
    for (size_t i = 0; i < transitions.size(); i++) {
      for (const std::tuple<PredicateSet, VariablesToMark, NodeId>& transition :
           transitions[i]) {
        out += "t " + std::to_string(i) + " " + std::get<0>(transition).to_string() + " "
               + std::to_string(std::get<2>(transition)) + "\n";
      }
    }
    for (size_t i = 0; i < epsilon_transitions.size(); i++) {
      for (const NodeId& end_node : epsilon_transitions[i]) {
        out += "t " + std::to_string(i) + " ε " + std::to_string(end_node) + "\n";
      }
    }

    return out;
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/union.hpp>
#pragma once
#include <gmpxx.h>

#include <cstdint>
#include <tuple>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"

namespace CORE::Internal::CEA {

class Union : public LogicalCEATransformer<Union> {
 public:
  using VariablesToMark = mpz_class;
  using EndNodeId = uint64_t;

  LogicalCEA eval(LogicalCEA& left, LogicalCEA& right) {
    LogicalCEA out = LogicalCEA(left);
    out.add_n_states(right.amount_of_states);
    out.initial_states |= right.initial_states << left.amount_of_states;
    out.final_states |= right.final_states << left.amount_of_states;
    for (int i = 0; i < right.amount_of_states; i++) {
      for (std::tuple<PredicateSet, VariablesToMark, EndNodeId> transition :
           right.transitions[i]) {
        out.transitions[i + left.amount_of_states].push_back(
          std::make_tuple(std::get<0>(transition),
                          std::get<1>(transition),
                          std::get<2>(transition) + left.amount_of_states));
      }
      for (EndNodeId end_node_id : right.epsilon_transitions[i]) {
        out.epsilon_transitions[i + left.amount_of_states].insert(
          end_node_id + left.amount_of_states);
      }
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/non_contiguous_iteration.hpp>
#pragma once
#include <cstdint>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"

namespace CORE::Internal::CEA {

/**
 * This construction takes a CEA A, creates a new state with a tautology loop
 * to itself and then adds epsilon transitions from all the final states from
 * A to the new state and from the new state to all the initial states of A
 */
class NonContiguousIteration : public LogicalCEATransformer<NonContiguousIteration> {
 public:
  LogicalCEA eval(LogicalCEA&& cea) {
    uint64_t new_state = cea.amount_of_states;
    cea.add_n_states(1);
    cea.transitions[new_state].emplace_back(PredicateSet(PredicateSet::Type::Tautology),
                                            0,
                                            new_state);

    for (auto final_state : cea.get_final_states())
      cea.epsilon_transitions[final_state].insert(new_state);

    for (auto initial_state : cea.get_initial_states())
      cea.epsilon_transitions[new_state].insert(initial_state);
    return cea;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/non_contiguous_sequencing.hpp>
#pragma once

#include <gmpxx.h>

#include <cstdint>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"
#include "union.hpp"

namespace CORE::Internal::CEA {

class NonContiguousSequencing : public LogicalCEATransformer<NonContiguousSequencing> {
 public:
  using VariablesToMark = mpz_class;
  using EndNodeId = uint64_t;

  // The difference between sequencing and concat is that
  // In sequencing there is a wildcard loop on the destination states.
  LogicalCEA eval(LogicalCEA& left, LogicalCEA& right) {
    LogicalCEA out = Union()(left, right);
    out.initial_states = left.initial_states;
    out.final_states = right.final_states << left.amount_of_states;
    auto left_final_states = left.get_final_states();
    auto right_initial_states = right.get_initial_states();

    // Tautology loop
    for (auto right_initial_state : right_initial_states) {
      uint64_t target_state_id = right_initial_state + left.amount_of_states;
      out.transitions[target_state_id]
        .emplace_back(PredicateSet(PredicateSet::Type::Tautology), 0, target_state_id);
    }

    for (auto left_final_state : left_final_states) {
      for (auto right_initial_state : right_initial_states) {
        EndNodeId target = right_initial_state + left.amount_of_states;
        out.epsilon_transitions[left_final_state].insert(target);
      }
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/contiguous_sequencing.hpp>
#pragma once

#include <gmpxx.h>

#include <cstdint>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "union.hpp"

namespace CORE::Internal::CEA {

class ContiguousSequencing : public LogicalCEATransformer<ContiguousSequencing> {
 public:
  using VariablesToMark = mpz_class;
  using EndNodeId = uint64_t;

  // Note, for this to work the implementation of union must offset the
  // right_states by the amount of states in the left_cea, and not make
  // another arbitrary permutation.
  LogicalCEA eval(LogicalCEA& left, LogicalCEA& right) {
    LogicalCEA out = Union()(left, right);
    out.initial_states = left.initial_states;
    out.final_states = right.final_states << left.amount_of_states;
    auto left_final_states = left.get_final_states();
    auto right_initial_states = right.get_initial_states();
    for (auto left_final_state : left_final_states) {
      for (auto right_initial_state : right_initial_states) {
        EndNodeId target = right_initial_state + left.amount_of_states;
        out.epsilon_transitions[left_final_state].insert(target);
      }
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/apply_atomic_filter.hpp>
#pragma once
#include <gmpxx.h>

#include <cassert>
#include <cstdint>
#include <limits>
#include <map>
#include <stdexcept>
#include <string>
#include <tuple>
#include <utility>

#include "core_server/internal/ceql/cel_formula/filters/atomic_filter.hpp"
#include "core_server/internal/coordination/query_catalog.hpp"
#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"
#include "shared/datatypes/aliases/event_type_id.hpp"

namespace CORE::Internal::CEA {

class ApplyAtomicFilter : public LogicalCEATransformer<ApplyAtomicFilter> {
  using VariablesToMark = mpz_class;
  using EndNodeId = uint64_t;
  using StreamName = std::string;
  using EventName = std::string;

 private:
  VariablesToMark variables_to_filter;
  uint64_t physical_predicate_id;
  PredicateSet predicate_set;

 public:
  ApplyAtomicFilter(uint64_t variable_id_to_filter, CEQL::AtomicFilter& atomic_filter)
      : variables_to_filter(mpz_class(1) << variable_id_to_filter),
        physical_predicate_id(atomic_filter.predicate->physical_predicate_id) {
    // The physical predicate id should be assigned
    // before starting the conversion to a LogicalCEA.
    assert(
      physical_predicate_id != std::numeric_limits<uint64_t>::max()
      && "Physical predicate ID should be added to query before creating the automaton.");
    predicate_set = PredicateSet(mpz_class(1) << physical_predicate_id,
                                 mpz_class(1) << physical_predicate_id);
  }

  ApplyAtomicFilter(
    const QueryCatalog& query_catalog,
    const std::map<std::pair<StreamName, EventName>, uint64_t>& stream_event_to_id,
    const StreamName stream_name,
    const EventName event_name,
    CEQL::AtomicFilter& atomic_filter)
      : physical_predicate_id(atomic_filter.predicate->physical_predicate_id) {
    // The physical predicate id should be assigned
    // before starting the conversion to a LogicalCEA.
    auto stream_event_id_iter = stream_event_to_id.find({stream_name, event_name});
    uint64_t stream_event_id = (stream_event_id_iter != stream_event_to_id.end())
                                 ? stream_event_id_iter->second
                                 : throw std::logic_error(
                                     "Stream/Event name combination not found");

    VariablesToMark stream_event = mpz_class(1) << stream_event_id;

    variables_to_filter = stream_event;
    assert(
      physical_predicate_id != std::numeric_limits<uint64_t>::max()
      && "Physical predicate ID should be added to query before creating the automaton.");
    predicate_set = PredicateSet(mpz_class(1) << physical_predicate_id,
                                 mpz_class(1) << physical_predicate_id);
  }

  ApplyAtomicFilter(
    const QueryCatalog& query_catalog,
    const std::map<std::pair<StreamName, EventName>, uint64_t>& stream_event_to_id,
    const EventName event_name,
    CEQL::AtomicFilter& atomic_filter)
      : physical_predicate_id(atomic_filter.predicate->physical_predicate_id) {
    // The physical predicate id should be assigned
    // before starting the conversion to a LogicalCEA.
    Types::EventNameTypeId
      query_event_name_id = query_catalog.get_query_event_name_id_from_event_name(
        event_name);

    VariablesToMark event = mpz_class(1)
                            << (stream_event_to_id.size() + query_event_name_id);

    variables_to_filter = event;
    assert(
      physical_predicate_id != std::numeric_limits<uint64_t>::max()
      && "Physical predicate ID should be added to query before creating the automaton.");
    predicate_set = PredicateSet(mpz_class(1) << physical_predicate_id,
                                 mpz_class(1) << physical_predicate_id);
  }

  LogicalCEA eval(LogicalCEA&& cea) {
    for (int i = 0; i < cea.amount_of_states; i++) {
      for (auto& transition : cea.transitions[i]) {
        if ((std::get<1>(transition) & variables_to_filter) != 0) {
          transition = std::make_tuple(std::get<0>(transition) & predicate_set,
                                       std::get<1>(transition),
                                       std::get<2>(transition));
        }
      }
    }
    return std::move(cea);
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/contiguous_iteration.hpp>
#pragma once
#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"

namespace CORE::Internal::CEA {

class ContiguousIteration : public LogicalCEATransformer<ContiguousIteration> {
 public:
  LogicalCEA eval(LogicalCEA&& cea) {
    for (auto final_state : cea.get_final_states())
      for (auto initial_state : cea.get_initial_states())
        cea.epsilon_transitions[final_state].insert(initial_state);
    return cea;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/mark_variable.hpp>
#pragma once
#include <gmpxx.h>

#include <cstdint>
#include <tuple>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"

namespace CORE::Internal::CEA {

class MarkVariable : public LogicalCEATransformer<MarkVariable> {
  using VariablesToMark = mpz_class;
  using EndNodeId = uint64_t;

 private:
  VariablesToMark variables_to_mark;

 public:
  MarkVariable(uint64_t variable_to_mark)
      : variables_to_mark(mpz_class(1) << variable_to_mark) {}

  LogicalCEA eval(LogicalCEA&& cea) {
    for (int i = 0; i < cea.amount_of_states; i++) {
      for (auto& transition : cea.transitions[i]) {
        if (std::get<1>(transition) == 0) {
          continue;
        }
        transition = std::make_tuple(std::get<0>(transition),
                                     std::get<1>(transition) | variables_to_mark,
                                     std::get<2>(transition));
      }
    }
    return cea;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/constructions/project.hpp>
#pragma once
#include <gmpxx.h>

#include <cstdint>
#include <tuple>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"

namespace CORE::Internal::CEA {

class Project : public LogicalCEATransformer<Project> {
  using VariablesToMark = mpz_class;
  using EndNodeId = uint64_t;

 private:
  VariablesToMark variables_to_project;

 public:
  Project(VariablesToMark variables_to_project)
      : variables_to_project(variables_to_project) {}

  LogicalCEA eval(LogicalCEA&& cea) {
    for (int i = 0; i < cea.amount_of_states; i++) {
      for (auto& transition : cea.transitions[i]) {
        transition = std::make_tuple(std::get<0>(transition),
                                     std::get<1>(transition) & variables_to_project,
                                     std::get<2>(transition));
      }
    }
    return cea;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/logical_cea_transformer.hpp>
#pragma once
#include <stdexcept>
#include <utility>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"

namespace CORE::Internal::CEA {

/**
 * This type of polymorphism is called CRTP that allows for interfaces with
 * no overhead created due virtual methods. This allows for documentation
 * and the ability of adding helper functions on methods that implement
 * this inferface
 */
template <class Derived>
class LogicalCEATransformer {
 public:
  LogicalCEA operator()(LogicalCEA&& cea) {
    return static_cast<Derived*>(this)->eval(std::move(cea));
  }

  LogicalCEA operator()(LogicalCEA& left, LogicalCEA& right) {
    return static_cast<Derived*>(this)->eval(left, right);
  }

  LogicalCEA eval(LogicalCEA&& query) {
    throw std::logic_error("eval(query) not implemented");
  }

  LogicalCEA eval(LogicalCEA&& left, LogicalCEA&& right) {
    throw std::logic_error("eval(left, right) not implemented");
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/optimizations/remove_unreachable_states.hpp>
#pragma once
#include <cassert>
#include <set>
#include <stack>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "remove_states.hpp"

namespace CORE::Internal::CEA {

class RemoveUnreachableStates : public LogicalCEATransformer<RemoveUnreachableStates> {
  using VariablesToMark = LogicalCEA::VariablesToMark;
  using NodeId = LogicalCEA::NodeId;

 public:
  RemoveUnreachableStates() {}

  /**
   * Simply does a DFS from the initial states
   * and removes the states that are not reached.
   */
  LogicalCEA eval(LogicalCEA&& cea) {
    std::vector<bool> reached_nodes(cea.amount_of_states, false);
    std::stack<NodeId> nodes_to_reach;
    for (NodeId node : cea.get_initial_states()) {
      reached_nodes[node] = true;
      nodes_to_reach.push(node);
    }
    while (!nodes_to_reach.empty()) {
      NodeId reached_node_id = nodes_to_reach.top();
      nodes_to_reach.pop();

      for (auto& transition : cea.transitions[reached_node_id]) {
        NodeId neighbor_node = std::get<2>(transition);
        if (!reached_nodes[neighbor_node]) {
          reached_nodes[neighbor_node] = true;
          nodes_to_reach.push(neighbor_node);
        }
      }

      for (NodeId neighbor_node : cea.epsilon_transitions[reached_node_id]) {
        if (!reached_nodes[neighbor_node]) {
          reached_nodes[neighbor_node] = true;
          nodes_to_reach.push(neighbor_node);
        }
      }
    }

    std::set<NodeId> states_to_remove;
    for (NodeId id = 0; id < reached_nodes.size(); id++) {
      if (!reached_nodes[id]) {
        states_to_remove.insert(id);
      }
    }
    if (states_to_remove.size() > 0) {
      return RemoveStates(states_to_remove)(std::move(cea));
    } else {
      return cea;
    }
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/optimizations/remove_epsilon_transitions.hpp>
#pragma once
#include <gmpxx.h>

#include <cassert>
#include <stack>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"

namespace CORE::Internal::CEA {

class RemoveEpsilonTransitions : public LogicalCEATransformer<RemoveEpsilonTransitions> {
  using VariablesToMark = LogicalCEA::VariablesToMark;
  using NodeId = LogicalCEA::NodeId;

 public:
  RemoveEpsilonTransitions() {}

  // May result in duplicate transitions, and that is OK
  // Duplicate transitions will be removed from LogicalCEA
  // to CEA.
  LogicalCEA eval(LogicalCEA&& cea) {
    LogicalCEA cea_copy = LogicalCEA(cea);
    for (int source_node = 0; source_node < cea.amount_of_states; source_node++) {
      cea_copy.transitions[source_node].clear();
      cea_copy.epsilon_transitions[source_node].clear();
    }

    for (int source_node = 0; source_node < cea.amount_of_states; source_node++) {
      std::vector<bool> visited(cea.amount_of_states, false);
      std::stack<NodeId> epsilon_reachable_nodes;
      epsilon_reachable_nodes.push(source_node);

      while (!epsilon_reachable_nodes.empty()) {
        NodeId reached_node = epsilon_reachable_nodes.top();
        epsilon_reachable_nodes.pop();

        if (!visited[reached_node]) {
          visited[reached_node] = true;

          for (auto& transition : cea.transitions[reached_node]) {
            cea_copy.transitions[source_node].push_back(transition);
          }

          check_if_reached_node_is_accepting(reached_node, source_node, cea_copy);

          for (NodeId neighbor : cea.epsilon_transitions[reached_node]) {
            if (!visited[neighbor]) {
              epsilon_reachable_nodes.push(neighbor);
            }
          }
        }
      }
    }

    return std::move(cea_copy);
  }

  // If the reached node is accepting, then the source node should be accepting too
  void check_if_reached_node_is_accepting(NodeId reached_node,
                                          NodeId source_node,
                                          LogicalCEA& cea) {
    mpz_class reached_binary = mpz_class(1) << reached_node;
    if ((reached_binary & cea.final_states) != 0) {
      mpz_class binary_source_node = mpz_class(1) << source_node;
      cea.final_states |= binary_source_node;
    }
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/optimizations/add_unique_initial_state.hpp>
#pragma once

#include <gmpxx.h>

#include <utility>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"

namespace CORE::Internal::CEA {

class AddUniqueInitialState : public LogicalCEATransformer<AddUniqueInitialState> {
  using NodeId = LogicalCEA::NodeId;

 public:
  AddUniqueInitialState() {}

  LogicalCEA eval(LogicalCEA&& cea) {
    cea.add_n_states(1);
    NodeId new_initial_state = cea.amount_of_states - 1;
    for (NodeId initial_state : cea.get_initial_states()) {
      cea.epsilon_transitions[new_initial_state].insert(initial_state);
    }
    cea.initial_states = mpz_class(1) << (cea.amount_of_states - 1);
    return std::move(cea);
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/optimizations/duplicate.hpp>
#pragma once
#include <cassert>
#include <tuple>
#include <utility>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"

namespace CORE::Internal::CEA {

/**
 * Duplicate is a transformation that maintains the language of the
 * automaton, but it allows for a simplification in the algorithm.
 * Through duplicating the automaton, we maintain the invariant that at
 * any point of the execution the active states are either a subset of
 * {0...n-1} or a subset of {n...2n-1}.
 */
class Duplicate : public LogicalCEATransformer<Duplicate> {
  using NodeId = LogicalCEA::NodeId;
  using Transition = LogicalCEA::Transition;
  using VariablesToMark = LogicalCEA::VariablesToMark;

 public:
  Duplicate() {}

  LogicalCEA eval(LogicalCEA&& cea) {
    LogicalCEA new_cea(cea.amount_of_states * 2);
    for (NodeId id = 0; id < cea.amount_of_states; id++) {
      for (Transition trans : cea.transitions[id]) {
        PredicateSet predicate = std::get<0>(trans);
        VariablesToMark vars = std::get<1>(trans);
        NodeId target = std::get<2>(trans);
        new_cea.transitions[id].push_back(
          std::make_tuple(predicate, vars, target + cea.amount_of_states));
        new_cea.transitions[id + cea.amount_of_states].push_back(
          std::make_tuple(predicate, vars, target));
        // Duplicate is meant only to be used on LogicalCEA's
        // without epsilon transitions.
        assert(cea.epsilon_transitions[id].size() == 0);
      }
    }
    new_cea.initial_states = cea.initial_states
                             | (cea.initial_states << cea.amount_of_states);
    new_cea.final_states = cea.final_states | (cea.final_states << cea.amount_of_states);
    return std::move(new_cea);
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/optimizations/remove_states.hpp>
#pragma once
#include <gmpxx.h>

#include <cassert>
#include <cstdint>
#include <set>
#include <tuple>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"

namespace CORE::Internal::CEA {

class RemoveStates : public LogicalCEATransformer<RemoveStates> {
 private:
  using VariablesToMark = LogicalCEA::VariablesToMark;
  using NodeId = LogicalCEA::NodeId;
  using Transition = LogicalCEA::Transition;
  using States = LogicalCEA::States;

  LogicalCEA new_cea{0};
  std::set<NodeId> nodes_to_discard;
  std::vector<int64_t> mapping;

 public:
  RemoveStates(std::set<NodeId> nodes_to_discard) : nodes_to_discard(nodes_to_discard) {}

  LogicalCEA eval(LogicalCEA&& cea) {
    assert(cea.amount_of_states >= nodes_to_discard.size());
    new_cea = LogicalCEA(cea.amount_of_states - nodes_to_discard.size());
    create_new_mapping(cea);
    for (NodeId old_state = 0; old_state < cea.amount_of_states; old_state++) {
      if (!nodes_to_discard.contains(old_state)) {
        NodeId new_state = mapping[old_state];
        assert(new_state != -1);
        transcribe_transitions(new_state, cea.transitions[old_state]);
        transcribe_epsilons(new_state, cea.epsilon_transitions[old_state]);
      }
    }

    new_cea.initial_states = map_states(cea.initial_states, mapping);
    new_cea.final_states = map_states(cea.final_states, mapping);
    return std::move(new_cea);
  }

 private:
  /**
   * Updates the mapping object to give a mapping from the old state ids
   * to the new state ids.
   */
  void create_new_mapping(LogicalCEA& cea) {
    mapping = std::vector<int64_t>(cea.amount_of_states, -1);
    int64_t new_state_id = 0;
    for (uint64_t previous_state_id = 0; previous_state_id < cea.amount_of_states;
         previous_state_id++) {
      if (!nodes_to_discard.contains(previous_state_id)) {
        mapping[previous_state_id] = new_state_id++;
      }
    }
    assert(new_state_id == new_cea.amount_of_states);
  }

  void transcribe_transitions(NodeId new_state, std::vector<Transition> transitions) {
    for (auto& transition : transitions) {
      NodeId previous_target_node = std::get<2>(transition);
      if (!nodes_to_discard.contains(previous_target_node)) {
        NodeId target_node = mapping[std::get<2>(transition)];
        assert(target_node != -1);
        auto new_transition = std::make_tuple(std::get<0>(transition),
                                              std::get<1>(transition),
                                              target_node);
        new_cea.transitions[new_state].push_back(new_transition);
      }
    }
  }

  void transcribe_epsilons(NodeId new_state, std::set<NodeId> transitions) {
    for (NodeId previous_target_node : transitions) {
      if (!nodes_to_discard.contains(previous_target_node)) {
        NodeId new_target_node = mapping[previous_target_node];
        assert(new_target_node != -1);
        new_cea.epsilon_transitions[new_state].insert(new_target_node);
      }
    }
  }

  States map_states(States states, std::vector<int64_t> new_mapping) {
    States out = 0;
    NodeId current_node = 0;
    mpz_class shifter = 1;
    while (states != 0) {
      if ((states & 1) == 1) {
        assert(current_node < new_mapping.size());
        NodeId new_state = new_mapping[current_node];
        if (new_state != -1) {
          out |= shifter << new_state;
        }
      }
      current_node++;
      states >>= 1;
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./logical_cea/transformations/optimizations/remove_useless_states.hpp>
#pragma once
#include <cassert>
#include <cwchar>
#include <set>
#include <stack>
#include <tuple>
#include <utility>
#include <vector>

#include "core_server/internal/evaluation/logical_cea/logical_cea.hpp"
#include "core_server/internal/evaluation/logical_cea/transformations/logical_cea_transformer.hpp"
#include "core_server/internal/evaluation/predicate_set.hpp"
#include "remove_states.hpp"

namespace CORE::Internal::CEA {

class RemoveUselessStates : public LogicalCEATransformer<RemoveUselessStates> {
  using VariablesToMark = LogicalCEA::VariablesToMark;
  using NodeId = LogicalCEA::NodeId;
  using Transition = LogicalCEA::Transition;

 public:
  RemoveUselessStates() {}

  /**
   * Simply does a backwards DFS from the final states
   * and removes the states that are not reached.
   */
  LogicalCEA eval(LogicalCEA&& cea) {
    auto backward_transitions = invert_transitions(cea.transitions);
    auto backward_epsilons = invert_transitions(cea.epsilon_transitions);

    std::vector<bool> reached_nodes(cea.amount_of_states, false);
    std::stack<NodeId> nodes_to_reach;
    for (NodeId node : cea.get_final_states()) {
      reached_nodes[node] = true;
      nodes_to_reach.push(node);
    }
    while (!nodes_to_reach.empty()) {
      NodeId reached_node_id = nodes_to_reach.top();
      nodes_to_reach.pop();

      for (auto& transition : backward_transitions[reached_node_id]) {
        NodeId neighbor_node = std::get<2>(transition);
        if (!reached_nodes[neighbor_node]) {
          reached_nodes[neighbor_node] = true;
          nodes_to_reach.push(neighbor_node);
        }
      }

      for (NodeId neighbor_node : backward_epsilons[reached_node_id]) {
        if (!reached_nodes[neighbor_node]) {
          reached_nodes[neighbor_node] = true;
          nodes_to_reach.push(neighbor_node);
        }
      }
    }

    std::set<NodeId> states_to_remove;
    for (NodeId id = 0; id < reached_nodes.size(); id++) {
      if (!reached_nodes[id]) {
        states_to_remove.insert(id);
      }
    }

    return RemoveStates(states_to_remove)(std::move(cea));
  }

  std::vector<std::vector<Transition>>
  invert_transitions(const std::vector<std::vector<Transition>>& transitions) {
    std::vector<std::vector<Transition>> out;
    for (size_t i = 0; i < transitions.size(); i++) {
      out.push_back({});
    }

    for (NodeId start = 0; start < transitions.size(); start++) {
      for (auto& transition : transitions[start]) {
        PredicateSet predicate = std::get<0>(transition);
        VariablesToMark vars = std::get<1>(transition);
        NodeId end = std::get<2>(transition);
        out[end].push_back(std::make_tuple(predicate, vars, start));
      }
    }
    return out;
  }

  std::vector<std::set<NodeId>>
  invert_transitions(const std::vector<std::set<NodeId>>& transitions) {
    std::vector<std::set<NodeId>> out;
    for (size_t i = 0; i < transitions.size(); i++) {
      out.push_back({});
    }

    for (NodeId start = 0; start < transitions.size(); start++) {
      for (NodeId end : transitions[start]) {
        out[end].insert(start);
      }
    }
    return out;
  }
};

}  // namespace CORE::Internal::CEA
</file>
<file ./predicate_set.hpp>
#pragma once
#include <gmpxx.h>

#include <cstdint>
#include <string>

namespace CORE::Internal::CEA {

struct PredicateSet {
  enum Type { Satisfiable, Contradiction, Tautology };

  mpz_class mask;        // Specifies relevant bits
  mpz_class predicates;  // expected evaluation
  Type type;

  PredicateSet(Type type = Contradiction) : mask(0), predicates(0), type(type) {}

  PredicateSet(mpz_class mask, mpz_class predicates)
      : mask(mask), predicates(predicates), type(Satisfiable) {}

  /**
   * This creates a new PredicateSet that is satisfied iff both this and
   * other are satisfied
   */
  PredicateSet operator&(const PredicateSet& other) const {
    if (type == Contradiction || other.type == Contradiction) {
      return PredicateSet(Contradiction);
    } else if (type == Tautology)
      return PredicateSet(other);
    else if (other.type == Tautology)
      return PredicateSet(*this);
    mpz_class conflict = (mask & other.mask) & (predicates ^ other.predicates);
    if (conflict != 0) {
      return PredicateSet(Contradiction);
    }

    mpz_class combined_mask = mask | other.mask;
    mpz_class combined_predicates = predicates | other.predicates;
    PredicateSet combined(combined_mask, combined_predicates);
    return combined;
  }

  PredicateSet negate(int64_t amount_of_bits) const {
    switch (type) {
      case Contradiction:
        return PredicateSet(Tautology);
      case Tautology:
        return PredicateSet(Contradiction);
      default:
        mpz_class unselective_mask = (mpz_class(1) << (amount_of_bits + 1)) - 1;
        mpz_class new_mask = unselective_mask ^ mask;
        mpz_class new_predicates = ~predicates;
        return PredicateSet(new_mask, new_predicates);
    }
  }

  bool is_satisfied_by(const mpz_class& predicate_evaluation) const {
    switch (type) {
      case Contradiction:
        return false;
      case Tautology:
        return true;
      default:
        mpz_class conflicts = (predicate_evaluation ^ predicates) & mask;
        return conflicts == 0;
    }
  }

  bool operator==(const PredicateSet other) const {
    if (type != other.type || mask != other.mask) return false;
    if (type == Contradiction || type == Tautology) return true;
    auto conflicts = static_cast<mpz_class>((predicates ^ other.predicates)) & mask;
    return conflicts == 0;
  }

  // For set comparison
  bool operator<(const PredicateSet other) const {
    if (type < other.type) return true;
    if (type > other.type) return false;
    if (mask < other.mask) return true;
    if (mask > other.mask) return false;
    if (mask < other.predicates) return true;
    return false;
  }

  std::string to_string() const {
    if (type == Contradiction)
      return "⊥";
    else if (type == Tautology)
      return "⊤";
    std::string out = predicates.get_str(2);
    std::string mask_string = mask.get_str(2);

    uint64_t buffer_length = out.size() > mask_string.size()
                               ? out.size() - mask_string.size()
                               : mask_string.size() - out.size();
    std::string buffer = "";
    for (int i = 0; i < buffer_length; i++) {
      buffer += '0';
    }

    if (out.size() > mask_string.size())
      out = buffer + out;
    else
      mask_string = buffer + mask_string;
    for (int i = 0; i <= out.size(); i++) {
      if (mask_string[i] == '0') {
        out[i] = '?';
      }
    }
    return out;
  }
};
}  // namespace CORE::Internal::CEA
</file>
<file ./evaluator.hpp>
#pragma once

#include <memory>
#include <optional>
#include <utility>

#include "core_server/internal/evaluation/enumeration/tecs/enumerator.hpp"
#include "core_server/internal/stream/ring_tuple_queue/tuple.hpp"
#include "shared/datatypes/eventWrapper.hpp"

#define QUILL_ROOT_LOGGER_ONLY
#include <gmpxx.h>
#include <quill/Quill.h>  // NOLINT
#include <quill/detail/LogMacros.h>
#include <quill/detail/misc/Common.h>

#include <atomic>
#include <cassert>
#include <cstdint>
#include <unordered_map>
#include <vector>

#include "core_server/internal/ceql/query/consume_by.hpp"
#include "core_server/internal/ceql/query/limit.hpp"
#include "core_server/internal/evaluation/enumeration/tecs/node.hpp"
#include "det_cea/det_cea.hpp"
#include "det_cea/state.hpp"
#include "enumeration/tecs/tecs.hpp"
#include "predicate_evaluator.hpp"
#include "shared/logging/setup.hpp"
#include "tracy/Tracy.hpp"

namespace CORE::Internal::Evaluation {
class Evaluator {
 private:
  using UnionList = std::vector<tECS::Node*>;
  using State = CEA::Det::State;
  using States = CEA::Det::State::States;
  using Node = tECS::Node;
  //                                   // Name in paper
  CEA::DetCEA& cea;                    // A
  PredicateEvaluator tuple_evaluator;  // t generator
  uint64_t time_window;                // ε

  std::unordered_map<State*, UnionList> historic_union_list_map;  // T
  std::vector<State*> historic_ordered_keys;
  std::unordered_map<State*, UnionList> current_union_list_map;  // T'
  std::vector<State*> current_ordered_keys;

  std::vector<State*> final_states;

  uint64_t actual_time;

  uint64_t current_iteration = 0;  // Current iteration of the algorithm as seen by next().

  /**
   * All events less than event_time_of_expiration can have it's children
   * recycled and marked as a dead node. Note that this uint64_t is passed
   * by reference to the tECS, and the tECS manages this behavior. This
   * uint64_t is a reference of the uint64_t stored at the mediator.
   */
  std::atomic<uint64_t>& event_time_of_expiration;

  // Other auxiliary objects

  // Use shared_ptr since enumerator may outlive the evaluator.
  std::shared_ptr<tECS::tECS> tecs{nullptr};

  CEQL::ConsumeBy::ConsumptionPolicy consumption_policy;
  CEQL::Limit enumeration_limit;

// Only in debug, check tuples are being sent in ascending order.
#ifdef CORE_DEBUG
  uint64_t last_tuple_time = 0;
#endif

 public:
  std::atomic<bool> should_reset = false;

  Evaluator(CEA::DetCEA& cea,
            PredicateEvaluator&& tuple_evaluator,
            uint64_t time_bound,
            std::atomic<uint64_t>& event_time_of_expiration,
            CEQL::ConsumeBy::ConsumptionPolicy consumption_policy,
            CEQL::Limit enumeration_limit)
      : cea(cea),
        tuple_evaluator(std::move(tuple_evaluator)),
        time_window(time_bound),
        event_time_of_expiration(event_time_of_expiration),
        tecs(std::make_shared<tECS::tECS>(event_time_of_expiration)),
        consumption_policy(consumption_policy),
        enumeration_limit(enumeration_limit) {}

  Evaluator(CEA::DetCEA& cea,
            const PredicateEvaluator& tuple_evaluator,
            uint64_t time_bound,
            std::atomic<uint64_t>& event_time_of_expiration,
            CEQL::ConsumeBy::ConsumptionPolicy consumption_policy,
            CEQL::Limit enumeration_limit)
      : cea(cea),
        tuple_evaluator(tuple_evaluator),
        time_window(time_bound),
        event_time_of_expiration(event_time_of_expiration),
        tecs(std::make_shared<tECS::tECS>(event_time_of_expiration)),
        consumption_policy(consumption_policy),
        enumeration_limit(enumeration_limit) {}

  std::optional<tECS::Enumerator>
  next(RingTupleQueue::Tuple tuple, Types::EventWrapper&& event, uint64_t current_time) {
    ZoneScopedN("Evaluator::next");
    LOG_L3_BACKTRACE("Received tuple with timestamp {} in Evaluator::next",
                     tuple.data_timestamp());
#if QUILL_ACTIVE_LOG_LEVEL <= QUILL_LOG_LEVEL_TRACE_L2
    auto start_time = std::chrono::steady_clock::now();
#endif
// If in debug, check tuples are being sent in ascending order.
#ifdef CORE_DEBUG
    assert(current_time >= last_tuple_time);
    last_tuple_time = current_time;
#endif
    // current_time is j in the algorithm.
    event_time_of_expiration = current_time < time_window ? 0 : current_time - time_window;

    if (should_reset.load()) {
      reset();
      should_reset.store(false);
    }

    mpz_class predicates_satisfied = tuple_evaluator(tuple, event);
    current_union_list_map = {};
    current_ordered_keys = {};
    final_states.clear();
    actual_time = current_time;
    UnionList ul = tecs->new_ulist(tecs->new_bottom(tuple, current_time));
    State* q0 = get_initial_state();
    exec_trans(tuple, q0, std::move(ul), predicates_satisfied, current_time);

    for (State* p : historic_ordered_keys) {
      assert(historic_union_list_map.contains(p));
      UnionList& actual_ul = historic_union_list_map[p];
      if (is_ul_out_time_window(actual_ul)) {
        tecs->unpin(actual_ul);
      } else {
        remove_out_of_time_nodes_ul(actual_ul);
        exec_trans(tuple,
                   p,
                   std::move(actual_ul),
                   predicates_satisfied,
                   current_time);  // Send the tuple in exec_trans.
      }
    }
    // Update the evicted states.
    cea.state_manager.unpin_states(historic_ordered_keys);
    historic_union_list_map = std::move(current_union_list_map);
    historic_ordered_keys = std::move(current_ordered_keys);
    current_iteration++;

    bool has_output = !final_states.empty();

    if (has_output) {
      LOG_L3_BACKTRACE("Outputting in Evaluator");
      tECS::Enumerator enumerator = output();
      assert(enumeration_limit.result_limit == 0
             || (enumerator.begin() != enumerator.end() && (enumerator.reset(), true)));
      if (consumption_policy == CEQL::ConsumeBy::ConsumptionPolicy::ANY
          || consumption_policy == CEQL::ConsumeBy::ConsumptionPolicy::PARTITION) {
        LOG_L3_BACKTRACE(
          "Setting should_reset to true due to consumption policy in Evaluator");
        should_reset.store(true);
      }
#if QUILL_ACTIVE_LOG_LEVEL <= QUILL_LOG_LEVEL_TRACE_L2
      auto end_time = std::chrono::steady_clock::now();
#endif
      LOG_TRACE_L2("Took {} seconds to process tuple with timestamp {}",
                   std::chrono::duration_cast<std::chrono::nanoseconds>(end_time
                                                                        - start_time),
                   tuple.data_timestamp());
      return std::move(enumerator);
    }
#if QUILL_ACTIVE_LOG_LEVEL <= QUILL_LOG_LEVEL_TRACE_L2
    auto end_time = std::chrono::steady_clock::now();
#endif
    LOG_TRACE_L2("Took {} seconds to process tuple with timestamp {}",
                 std::chrono::duration_cast<std::chrono::nanoseconds>(end_time
                                                                      - start_time),
                 tuple.data_timestamp());
    return {};
  }

 private:
  State* get_initial_state() { return cea.initial_state; }

  void reset() {
    LOG_L3_BACKTRACE("Resetting historic states in Evaluator");
    cea.state_manager.unpin_states(historic_ordered_keys);
    historic_ordered_keys.clear();
    for (auto& [state, ul] : historic_union_list_map) {
      tecs->unpin(ul);
    }
  }

  bool is_ul_out_time_window(const UnionList& ul) {
    ZoneScopedN("Evaluator::is_ul_out_time_window");
    return (ul.at(0)->maximum_start < event_time_of_expiration);
  }

  void remove_out_of_time_nodes_ul(UnionList& ul) {
    ZoneScopedN("Evaluator::remove_dead_nodes_ul");
    for (auto it = ul.begin(); it != ul.end();) {
      Node* ul_node = *it;
      if (ul_node->maximum_start < event_time_of_expiration) {
        it = ul.erase(it);
        tecs->unpin(ul_node);
      } else {
        ++it;
      }
    }
  }

  void exec_trans(RingTupleQueue::Tuple& tuple,
                  State* p,
                  UnionList&& ul,
                  mpz_class& t,
                  uint64_t current_time) {
    // exec_trans places all the code of add into exec_trans.
    ZoneScopedN("Evaluator::exec_trans");
    LOG_L3_BACKTRACE("Received tuple with timestamp {} in Evaluator::exec_trans",
                     tuple.data_timestamp());
    assert(p != nullptr);
    States next_states = cea.next(p, t, current_iteration);
    auto marked_state = next_states.marked_state;
    auto unmarked_state = next_states.unmarked_state;
    assert(marked_state != nullptr && unmarked_state != nullptr);
    bool recycle_ulist = false;
    if (!marked_state->is_empty) {
      Node* new_node = tecs->new_extend(tecs->merge(ul), tuple, current_time);
      if (current_union_list_map.contains(marked_state)) {
        current_union_list_map[marked_state] = tecs->insert(
          std::move(current_union_list_map[marked_state]), new_node);
      } else {
        UnionList new_ulist = tecs->new_ulist(new_node);
        current_ordered_keys.push_back(marked_state);
        cea.state_manager.pin_state(marked_state);
        current_union_list_map[marked_state] = new_ulist;
        if (marked_state->is_final) {
          final_states.push_back(marked_state);
        }
      }
    }
    if (!unmarked_state->is_empty) {
      if (current_union_list_map.contains(unmarked_state)) {
        Node* new_node = tecs->merge(ul);
        current_union_list_map[unmarked_state] = tecs->insert(
          std::move(current_union_list_map[unmarked_state]), new_node);
      } else {
        current_ordered_keys.push_back(unmarked_state);
        cea.state_manager.pin_state(unmarked_state);
        current_union_list_map[unmarked_state] = ul;
        recycle_ulist = true;
        if (unmarked_state->is_final) {
          final_states.push_back(unmarked_state);
        }
      }
    }
    if (!recycle_ulist) {
      tecs->unpin(ul);
    }
  }

  // Change to tECS::Enumerator.
  tECS::Enumerator output() {
    ZoneScopedN("Evaluator::output");
    Node* out = nullptr;
    for (auto it = final_states.rbegin(); it != final_states.rend(); ++it) {
      State* p = *it;
      // If using ANY consumption policy, this assert will always fail due resetting state
      assert(historic_union_list_map.contains(p));
      Node* n = tecs->merge(historic_union_list_map[p]);
      // Aca hacer el union del nodo antiguo (si hay) con el nuevo nodo.
      if (out == nullptr) {
        out = n;
      } else {
        out = tecs->new_direct_union(n, out);
      }
    }
    // TODO: Take off the if statement when fixing online_query_evaluator empty enumerator problem
    if (out == nullptr) {
      return {};
    } else {
      tecs->pin(out);
      return {out,
              actual_time,
              time_window,
              tecs,
              tecs->time_reservator,
              enumeration_limit.result_limit};
    }
  }
};

}  // namespace CORE::Internal::Evaluation
</file>
<file ./minipool/minipool.hpp>
#pragma once

#include <cmath>
#include <cstddef>
#include <vector>

namespace CORE::Internal::MiniPool {

/**
 * Different Manager can use MiniPools to store their data. A MiniPool is a
 * linked list of nodes, where each node is a chunk of memory.
 */
template <typename item>
class MiniPool {
 private:
  size_t capacity_;
  std::vector<item> item_container{};
  MiniPool* next_{nullptr};
  MiniPool* prev_{nullptr};

 public:
  MiniPool(size_t cap) : capacity_(cap) { item_container.reserve(capacity_); }

  size_t capacity() const { return item_container.capacity(); }

  size_t size() const { return item_container.size(); }

  bool is_full() const { return item_container.size() >= capacity_; }

  MiniPool* next() const { return next_; }

  void set_next(MiniPool* mp) { next_ = mp; }

  MiniPool* prev() const { return prev_; }

  void set_prev(MiniPool* mp) { prev_ = mp; }

  template <class... Args>
  item* alloc(Args&&... args) {
    item_container.emplace_back(std::forward<Args>(args)...);
    return &item_container.back();
  }
};
}  // namespace CORE::Internal::MiniPool
</file>
