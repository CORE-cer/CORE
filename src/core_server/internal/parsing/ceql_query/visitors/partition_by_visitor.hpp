#pragma once

#include <any>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/query/partition_by.hpp"
#include "core_server/internal/ceql/value/attribute.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"

namespace CORE::Internal::Parsing {
class PartitionByVisitor : public CEQLQueryParserBaseVisitor {
 private:
  std::vector<std::vector<CEQL::Attribute>> attributes = {};
  std::map<std::string, std::vector<Types::EventInfo>>& streams_events;

 public:
  PartitionByVisitor(std::map<std::string, std::vector<Types::EventInfo>>& streams_events)
      : streams_events(streams_events) {}

  CEQL::PartitionBy get_parsed_partition_by() {
    return CEQL::PartitionBy(std::move(attributes));
  }

  virtual std::any visitCore_query(CEQLQueryParser::Core_queryContext* ctx) override {
    if (ctx->partition_list()) visit(ctx->partition_list());
    return {};
  }

  virtual std::any
  visitAttribute_list(CEQLQueryParser::Attribute_listContext* ctx) override {
    std::vector<CEQL::Attribute> attribute_list = {};
    for (auto& attr : ctx->attribute_name()) {
      check_if_attribute_is_defined(attr->getText(), streams_events);
      attribute_list.emplace_back(attr->getText());
    }
    attributes.push_back(std::move(attribute_list));
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
