#pragma once

#include <any>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/cel_formula/filters/and_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/atomic_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/or_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/visitors/filter_visitor.hpp"
#include "core_server/internal/ceql/cel_formula/predicate/predicate.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"
#include "predicate_visitor.hpp"
#include "shared/datatypes/catalog/event_info.hpp"
#include "shared/exceptions/parsing/attribute_not_defined_exception.hpp"

namespace CORE::Internal::Parsing {
class FilterVisitor : public CEQLQueryParserBaseVisitor {
 private:
  // this filter is the corresponding parsed filter after the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Filter> filter;

  PredicateVisitor predicate_visitor;

  Catalog& catalog;
  std::map<std::string, std::vector<Types::EventInfo>>& streams_events;
  std::map<std::string, std::vector<Types::EventInfo>> as_events_map_info;

 public:
  std::unique_ptr<CEQL::Filter> get_parsed_filter() { return std::move(filter); }

  FilterVisitor(Catalog& catalog,
                std::map<std::string, std::vector<Types::EventInfo>>& streams_events)
      : catalog(catalog), streams_events(streams_events) {}

  void
  add_as_events_to_map(std::string event_name, std::vector<Types::EventInfo> event_info) {
    as_events_map_info.insert(std::make_pair(event_name, event_info));
  }

  virtual std::any
  visitAtomic_filter(CEQLQueryParser::Atomic_filterContext* ctx) override {
    predicate_visitor.visit(ctx->predicate());
    std::unique_ptr<CEQL::Predicate> filter_from_predicate = predicate_visitor
                                                               .get_parsed_predicate();
    std::set<std::string> attributes = predicate_visitor.get_attributes();
    std::string event_name = ctx->s_event_name()->event_name()->getText();
    check_if_event_is_defined(event_name, streams_events, as_events_map_info);
    if (ctx->s_event_name()->stream_name()) {
      std::string stream_name = ctx->s_event_name()->stream_name()->getText();
      check_event_in_specific_stream(stream_name, event_name, streams_events);
      filter = std::make_unique<CEQL::AtomicFilter>(stream_name,
                                                    event_name,
                                                    std::move(filter_from_predicate));
    } else {
      // Since events name can be repeated between different events, the parser only
      // verifies if the attribute is defined in any of the events
      if (!check_if_attribute_exist_in_as_events(event_name, attributes, as_events_map_info)
          && !check_if_attributes_are_defined(attributes, streams_events)) {
        throw AttributeNotDefinedException("Warning: One or more of these attributes [");
      }
      // check_if_attributes_are_defined(attributes, streams_events, as_events_map_info);
      filter = std::make_unique<CEQL::AtomicFilter>(event_name,
                                                    std::move(filter_from_predicate));
    }
    return {};
  }

  virtual std::any visitAnd_filter(CEQLQueryParser::And_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter = std::make_unique<CEQL::AndFilter>(std::move(left), std::move(filter));
    return {};
  }

  virtual std::any visitOr_filter(CEQLQueryParser::Or_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter = std::make_unique<CEQL::OrFilter>(std::move(left), std::move(filter));
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
