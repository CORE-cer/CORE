#pragma once

#include <any>
#include <memory>
#include <utility>

#include "core_server/internal/ceql/cel_formula/filters/and_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/atomic_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/or_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/visitors/filter_visitor.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "predicate_visitor.hpp"

namespace CORE::Internal::Parsing {
class FilterVisitorCatalog : public CEQLQueryParserBaseVisitor {
 private:
  // this filter is the corresponding parsed filter after the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Filter> filter;

  PredicateVisitor predicate_visitor;

  Catalog& catalog;
  std::map<std::string, std::vector<Types::EventInfo>>& streams_events;
  std::vector<std::string> as_events;

 public:
  std::unique_ptr<CEQL::Filter> get_parsed_filter() { return std::move(filter); }

  FilterVisitorCatalog(Catalog& catalog,
                       std::map<std::string, std::vector<Types::EventInfo>>& streams_events)
      : catalog(catalog), streams_events(streams_events) {}

  virtual std::any
  visitAtomic_filter(CEQLQueryParser::Atomic_filterContext* ctx) override {
    predicate_visitor.visit(ctx->predicate());
    std::unique_ptr<CEQL::Predicate> filter_from_predicate = predicate_visitor
                                                               .get_parsed_predicate();
    std::vector<std::string> attributes = predicate_visitor.get_attributes();
    if (ctx->s_event_name()->stream_name()) {
      filter = std::make_unique<CEQL::AtomicFilter>(
        ctx->s_event_name()->stream_name()->getText(),
        ctx->s_event_name()->event_name()->getText(),
        std::move(filter_from_predicate));
    } else {
      filter = std::make_unique<CEQL::AtomicFilter>(
        ctx->s_event_name()->event_name()->getText(), std::move(filter_from_predicate));
    }
    return {};
  }

  virtual std::any visitAnd_filter(CEQLQueryParser::And_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter = std::make_unique<CEQL::AndFilter>(std::move(left), std::move(filter));
    return {};
  }

  virtual std::any visitOr_filter(CEQLQueryParser::Or_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter = std::make_unique<CEQL::OrFilter>(std::move(left), std::move(filter));
    return {};
  }
};

class FilterVisitor : public CEQLQueryParserBaseVisitor {
 private:
  // this filter is the corresponding parsed filter after the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Filter> filter;

  PredicateVisitor predicate_visitor;

 public:
  std::unique_ptr<CEQL::Filter> get_parsed_filter() { return std::move(filter); }

  virtual std::any
  visitAtomic_filter(CEQLQueryParser::Atomic_filterContext* ctx) override {
    predicate_visitor.visit(ctx->predicate());
    if (ctx->s_event_name()->stream_name()) {
      filter = std::make_unique<CEQL::AtomicFilter>(
        ctx->s_event_name()->stream_name()->getText(),
        ctx->s_event_name()->event_name()->getText(),
        predicate_visitor.get_parsed_predicate());
    } else {
      filter = std::make_unique<CEQL::AtomicFilter>(
        ctx->s_event_name()->event_name()->getText(),
        predicate_visitor.get_parsed_predicate());
    }
    return {};
  }

  virtual std::any visitAnd_filter(CEQLQueryParser::And_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter = std::make_unique<CEQL::AndFilter>(std::move(left), std::move(filter));
    return {};
  }

  virtual std::any visitOr_filter(CEQLQueryParser::Or_filterContext* ctx) override {
    visit(ctx->filter()[0]);
    auto left = std::move(filter);
    visit(ctx->filter()[1]);
    filter = std::make_unique<CEQL::OrFilter>(std::move(left), std::move(filter));
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
