#pragma once

#include <any>
#include <cassert>
#include <memory>
#include <set>
#include <string>
#include <utility>

#include "core_server/internal/ceql/cel_formula/formula/formula_headers.hpp"
#include "core_server/internal/ceql/cel_formula/formula/projection_formula.hpp"
#include "core_server/internal/ceql/query/select.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"

namespace CORE::Internal::Parsing {

class SelectVisitorCatalog : public CEQLQueryParserBaseVisitor {
  using VariableName = std::string;
  using StreamName = std::string;

 private:
  CEQL::Select::Strategy strategy = CEQL::Select::Strategy::DEFAULT;
  std::set<VariableName> variables;
  std::set<std::pair<StreamName, VariableName>> streams_events;
  bool is_star = false;
  std::unique_ptr<CEQL::ProjectionFormula> formula;
  Catalog& catalog;
  std::map<std::string, std::vector<Types::EventInfo>>& streams_events_map;

 public:
  SelectVisitorCatalog(Catalog& catalog,
                       std::map<std::string, std::vector<Types::EventInfo>>& streams_events)
      : catalog(catalog), streams_events_map(streams_events) {}

  CEQL::Select get_parsed_select() {
    return CEQL::Select(std::move(strategy), std::move(is_star), std::move(formula));
  }

  virtual std::any visitCore_query(CEQLQueryParser::Core_queryContext* ctx) override {
    // Visiting Selection Strategy will update the strategy.
    auto selection_strategy_ctx = ctx->selection_strategy();
    if (selection_strategy_ctx) {
      visit(selection_strategy_ctx);
    }
    // Visiting result_values will add all variable_names
    visit(ctx->list_of_variables());
    formula = std::make_unique<CEQL::ProjectionFormula>(std::move(variables),
                                                        std::move(streams_events));
    return {};
  }

  virtual std::any visitS_star(CEQLQueryParser::S_starContext* ctx) override {
    assert(variables.empty());
    assert(streams_events.empty());
    is_star = true;
    return {};
  }

  virtual std::any visitS_none(CEQLQueryParser::S_noneContext* ctx) override {
    assert(variables.empty());
    assert(streams_events.empty());
    return {};
  }

  virtual std::any visitS_event_name(CEQLQueryParser::S_event_nameContext* ctx) override {
    std::string event_name = ctx->event_name()->getText();
    if (ctx->stream_name()) {
      std::string stream_name = ctx->stream_name()->getText();
      check_event_in_specific_stream(stream_name, event_name, streams_events_map);
      streams_events.insert({stream_name, event_name});
    } else {
      check_if_event_exists_in_streams(event_name, streams_events_map);
      variables.insert(ctx->event_name()->getText());
    }
    return {};
  }

  virtual std::any visitSs_all(CEQLQueryParser::Ss_allContext* ctx) override {
    strategy = CEQL::Select::Strategy::ALL;
    return {};
  }

  virtual std::any visitSs_any(CEQLQueryParser::Ss_anyContext* ctx) override {
    strategy = CEQL::Select::Strategy::ANY;
    return {};
  }

  virtual std::any visitSs_last(CEQLQueryParser::Ss_lastContext* ctx) override {
    strategy = CEQL::Select::Strategy::LAST;
    return {};
  }

  virtual std::any visitSs_max(CEQLQueryParser::Ss_maxContext* ctx) override {
    strategy = CEQL::Select::Strategy::MAX;
    return {};
  }

  virtual std::any visitSs_next(CEQLQueryParser::Ss_nextContext* ctx) override {
    strategy = CEQL::Select::Strategy::NEXT;
    return {};
  }

  virtual std::any visitSs_strict(CEQLQueryParser::Ss_strictContext* ctx) override {
    strategy = CEQL::Select::Strategy::STRICT;
    return {};
  }
};

class SelectVisitor : public CEQLQueryParserBaseVisitor {
  using VariableName = std::string;
  using StreamName = std::string;

 private:
  CEQL::Select::Strategy strategy = CEQL::Select::Strategy::DEFAULT;
  std::set<VariableName> variables;
  std::set<std::pair<StreamName, VariableName>> streams_events;
  bool is_star = false;
  std::unique_ptr<CEQL::ProjectionFormula> formula;

 public:
  CEQL::Select get_parsed_select() {
    return CEQL::Select(std::move(strategy), std::move(is_star), std::move(formula));
  }

  virtual std::any visitCore_query(CEQLQueryParser::Core_queryContext* ctx) override {
    // Visiting Selection Strategy will update the strategy.
    auto selection_strategy_ctx = ctx->selection_strategy();
    if (selection_strategy_ctx) {
      visit(selection_strategy_ctx);
    }
    // Visiting result_values will add all variable_names
    visit(ctx->list_of_variables());
    formula = std::make_unique<CEQL::ProjectionFormula>(std::move(variables),
                                                        std::move(streams_events));
    return {};
  }

  virtual std::any visitS_star(CEQLQueryParser::S_starContext* ctx) override {
    assert(variables.empty());
    assert(streams_events.empty());
    is_star = true;
    return {};
  }

  virtual std::any visitS_none(CEQLQueryParser::S_noneContext* ctx) override {
    assert(variables.empty());
    assert(streams_events.empty());
    return {};
  }

  virtual std::any visitS_event_name(CEQLQueryParser::S_event_nameContext* ctx) override {
    if (ctx->stream_name()) {
      streams_events.insert({ctx->stream_name()->getText(), ctx->event_name()->getText()});
    } else {
      variables.insert(ctx->event_name()->getText());
    }
    return {};
  }

  virtual std::any visitSs_all(CEQLQueryParser::Ss_allContext* ctx) override {
    strategy = CEQL::Select::Strategy::ALL;
    return {};
  }

  virtual std::any visitSs_any(CEQLQueryParser::Ss_anyContext* ctx) override {
    strategy = CEQL::Select::Strategy::ANY;
    return {};
  }

  virtual std::any visitSs_last(CEQLQueryParser::Ss_lastContext* ctx) override {
    strategy = CEQL::Select::Strategy::LAST;
    return {};
  }

  virtual std::any visitSs_max(CEQLQueryParser::Ss_maxContext* ctx) override {
    strategy = CEQL::Select::Strategy::MAX;
    return {};
  }

  virtual std::any visitSs_next(CEQLQueryParser::Ss_nextContext* ctx) override {
    strategy = CEQL::Select::Strategy::NEXT;
    return {};
  }

  virtual std::any visitSs_strict(CEQLQueryParser::Ss_strictContext* ctx) override {
    strategy = CEQL::Select::Strategy::STRICT;
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
