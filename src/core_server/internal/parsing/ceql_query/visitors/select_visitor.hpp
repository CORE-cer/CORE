#pragma once

#include <any>
#include <cassert>
#include <map>
#include <memory>
#include <optional>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/cel_formula/formula/projection_formula.hpp"
#include "core_server/internal/ceql/query/select.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"
#include "shared/datatypes/catalog/event_info.hpp"

namespace CORE::Internal::Parsing {

class SelectVisitor : public CEQLQueryParserBaseVisitor {
  using VariableName = std::string;
  using StreamName = std::string;
  using AttributeName = std::string;

 private:
  CEQL::Select::Strategy strategy = CEQL::Select::Strategy::DEFAULT;
  std::set<VariableName> variables;
  std::set<std::pair<StreamName, VariableName>> streams_events;
  bool is_star = false;
  std::unique_ptr<CEQL::ProjectionFormula> formula;
  Catalog& catalog;
  std::map<std::string, std::vector<Types::EventInfo>>& streams_events_map;
  std::vector<std::string>& as_events;

  // Attribute projection
  std::map<VariableName, std::vector<AttributeName>> attribute_projection_variable;
  std::map<std::pair<StreamName, VariableName>, std::vector<AttributeName>>
    attribute_projection_stream_event;

  void check_if_events_exists_in_streams_or_as_events(std::string event_name) {
    bool as_formula_found = false;
    for (const std::string& event : as_events) {
      if (event == event_name) {
        as_formula_found = true;
        break;
      }
    }
    if (!as_formula_found) {
      check_if_event_exists_in_streams(event_name, streams_events_map);
    }
  }

 public:
  SelectVisitor(Catalog& catalog,
                std::map<std::string, std::vector<Types::EventInfo>>& streams_events,
                std::vector<std::string>& as_events)
      : catalog(catalog), streams_events_map(streams_events), as_events(as_events) {}

  CEQL::Select get_parsed_select() {
    return CEQL::Select(std::move(strategy),
                        std::move(is_star),
                        std::move(formula),
                        std::move(attribute_projection_variable),
                        std::move(attribute_projection_stream_event));
  }

  virtual std::any visitCore_query(CEQLQueryParser::Core_queryContext* ctx) override {
    // Visiting Selection Strategy will update the strategy.
    auto selection_strategy_ctx = ctx->selection_strategy();
    if (selection_strategy_ctx) {
      visit(selection_strategy_ctx);
    }
    // Visiting result_values will add all variable_names
    visit(ctx->list_of_variables());
    formula = std::make_unique<CEQL::ProjectionFormula>(std::move(variables),
                                                        std::move(streams_events));
    return {};
  }

  virtual std::any visitS_star(CEQLQueryParser::S_starContext* ctx) override {
    assert(variables.empty());
    assert(streams_events.empty());
    is_star = true;
    return {};
  }

  virtual std::any visitS_none(CEQLQueryParser::S_noneContext* ctx) override {
    assert(variables.empty());
    assert(streams_events.empty());
    return {};
  }

  virtual std::any visitS_event_name_with_projection(
    CEQLQueryParser::S_event_name_with_projectionContext* ctx) override {
    auto [stream_name, event_name] = std::any_cast<
      std::pair<std::optional<StreamName>, std::string>>(visit(ctx->s_event_name()));

    if (!ctx->list_of_attribute_names()) {
      return {};
    }
    auto attribute_names = std::any_cast<std::vector<AttributeName>>(
      visit(ctx->list_of_attribute_names()));

    if (stream_name) {
      auto stream_event_pair = std::make_pair(stream_name.value(), event_name);
      streams_events.emplace(stream_event_pair);
      attribute_projection_stream_event.emplace(stream_event_pair, attribute_names);
    } else {
      variables.emplace(event_name);
      attribute_projection_variable.emplace(event_name, attribute_names);
    }

    return {};
  }

  virtual std::any visitS_event_name(CEQLQueryParser::S_event_nameContext* ctx) override {
    std::string event_name = ctx->event_name()->getText();
    if (ctx->stream_name()) {
      std::string stream_name = ctx->stream_name()->getText();
      check_event_in_specific_stream(stream_name, event_name, streams_events_map);
      streams_events.emplace(stream_name, event_name);
      return std::make_pair(std::optional<StreamName>(stream_name), event_name);
    } else {
      check_if_events_exists_in_streams_or_as_events(event_name);
      variables.emplace(event_name);
      return std::make_pair(std::optional<StreamName>(), event_name);
    }
    return {};
  }

  virtual std::any visitList_of_attribute_names(
    CEQLQueryParser::List_of_attribute_namesContext* ctx) override {
    std::vector<AttributeName> attribute_names;
    for (auto& attr : ctx->attribute_name()) {
      attribute_names.emplace_back(attr->getText());
    }
    return attribute_names;
  }

  virtual std::any visitSs_all(CEQLQueryParser::Ss_allContext* ctx) override {
    strategy = CEQL::Select::Strategy::ALL;
    return {};
  }

  virtual std::any visitSs_any(CEQLQueryParser::Ss_anyContext* ctx) override {
    strategy = CEQL::Select::Strategy::ANY;
    return {};
  }

  virtual std::any visitSs_last(CEQLQueryParser::Ss_lastContext* ctx) override {
    strategy = CEQL::Select::Strategy::LAST;
    return {};
  }

  virtual std::any visitSs_max(CEQLQueryParser::Ss_maxContext* ctx) override {
    strategy = CEQL::Select::Strategy::MAX;
    return {};
  }

  virtual std::any visitSs_next(CEQLQueryParser::Ss_nextContext* ctx) override {
    strategy = CEQL::Select::Strategy::NEXT;
    return {};
  }

  virtual std::any visitSs_strict(CEQLQueryParser::Ss_strictContext* ctx) override {
    strategy = CEQL::Select::Strategy::STRICT;
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
