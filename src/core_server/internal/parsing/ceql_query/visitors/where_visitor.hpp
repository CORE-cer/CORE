#pragma once

#include <any>
#include <memory>
#include <utility>

#include "core_server/internal/ceql/cel_formula/formula/as_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/contiguous_iteration_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/contiguous_sequencing_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/event_type_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/filter_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/formula_headers.hpp"
#include "core_server/internal/ceql/cel_formula/formula/non_contiguous_iteration_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/non_contiguous_sequencing_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/or_formula.hpp"
#include "core_server/internal/ceql/query/where.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"
#include "filter_visitor.hpp"
#include "shared/exceptions/event_not_in_stream_exception.hpp"

namespace CORE::Internal::Parsing {
class WhereVisitorCatalog : public CEQLQueryParserBaseVisitor {
 private:
  // this formula is the corresponding parsed formula after parsing the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Formula> formula;
  Catalog& catalog;
  std::set<std::string>& streams;
  std::map<std::string, std::vector<Types::EventInfo>> streams_events;

  FilterVisitor filter_visitor;

  void set_streams_events_map() {
    const std::vector<Types::StreamInfo>& streams_info = catalog.get_stream_info_vector();
    for (const auto& stream_name : streams) {
      auto it = std::find_if(streams_info.begin(),
                             streams_info.end(),
                             [&](const Types::StreamInfo& stream) {
                               return stream.name == stream_name;
                             });
      const Types::StreamInfo&
        actual_stream_info = streams_info[std::distance(streams_info.begin(), it)];
      streams_events.insert({actual_stream_info.name, actual_stream_info.events_info});
    }
  }

  bool check_if_event_exists_in_streams(std::string event_name) {
    for (const auto& pair : streams_events) {
      for (const auto& event : pair.second) {
        if (event.name == event_name) {
          return true;
        }
      }
    }
    return false;
  }

  bool check_event_in_specific_stream(std::string stream_name, std::string event_name) {
    auto it = streams_events.find(stream_name);
    if (it != streams_events.end()) {
      for (const auto& event : it->second) {
        // Verificar si el nombre del evento coincide
        if (event.name == event_name) {
          return true;  // Se encontr√≥ el evento
        }
      }
    }
    return false;
  }

 public:
  WhereVisitorCatalog(Catalog& catalog, std::set<std::string>& streams)
      : catalog(catalog), streams(streams) {
    set_streams_events_map();
  }

  CEQL::Where get_parsed_where() { return CEQL::Where(std::move(formula)); }

  virtual std::any visitCore_query(CEQLQueryParser::Core_queryContext* ctx) override {
    // Visiting Where clause will identify all streams.
    auto cel_formula_ctx = ctx->cel_formula();
    visit(cel_formula_ctx);
    return {};  // Only interested in stream names
  }

  virtual std::any visitEvent_type_cel_formula(
    CEQLQueryParser::Event_type_cel_formulaContext* ctx) override {
    if (ctx->s_event_name()->stream_name() == nullptr) {
      std::string event_name = ctx->s_event_name()->event_name()->getText();
      if (check_if_event_exists_in_streams(event_name)) {
        formula = std::make_unique<CEQL::EventTypeFormula>(event_name);
      } else {
        throw CORE::EventNotInStreamException("The event: " + event_name
                                              + " is not in any of the streams");
      }
    } else {
      std::string stream_name = ctx->s_event_name()->stream_name()->getText();
      std::string event_name = ctx->s_event_name()->event_name()->getText();
      if (check_event_in_specific_stream(stream_name, event_name)) {
        formula = std::make_unique<CEQL::EventTypeFormula>(stream_name, event_name);
      } else {
        throw CORE::EventNotInStreamException(
          "The event: " + event_name + " is not in the specified stream " + stream_name);
      }
    }
    return {};
  }

  virtual std::any
  visitAs_cel_formula(CEQLQueryParser::As_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    formula = std::make_unique<CEQL::AsFormula>(std::move(formula),
                                                ctx->event_name()->getText());

    return {};
  }

  virtual std::any visitNon_contiguous_iteration_cel_formula(
    CEQLQueryParser::Non_contiguous_iteration_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    formula = std::make_unique<CEQL::NonContiguousIterationFormula>(std::move(formula));
    return {};
  }

  virtual std::any visitNon_contiguous_sequencing_cel_formula(
    CEQLQueryParser::Non_contiguous_sequencing_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula()[0]);
    auto first_formula = std::move(formula);
    visit(ctx->cel_formula()[1]);
    formula = std::make_unique<CEQL::NonContiguousSequencingFormula>(std::move(
                                                                       first_formula),
                                                                     std::move(formula));
    return {};
  }

  virtual std::any visitContiguous_sequencing_cel_formula(
    CEQLQueryParser::Contiguous_sequencing_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula()[0]);
    auto first_formula = std::move(formula);
    visit(ctx->cel_formula()[1]);
    formula = std::make_unique<CEQL::ContiguousSequencingFormula>(std::move(first_formula),
                                                                  std::move(formula));
    return {};
  }

  virtual std::any
  visitOr_cel_formula(CEQLQueryParser::Or_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula()[0]);
    auto first_formula = std::move(formula);
    visit(ctx->cel_formula()[1]);
    formula = std::make_unique<CEQL::OrFormula>(std::move(first_formula),
                                                std::move(formula));
    return {};
  }

  virtual std::any
  visitFilter_cel_formula(CEQLQueryParser::Filter_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    filter_visitor.visit(ctx->filter());
    formula = std::make_unique<CEQL::FilterFormula>(std::move(formula),
                                                    filter_visitor.get_parsed_filter());
    return {};
  }

  virtual std::any visitContiguous_iteration_cel_formula(
    CEQLQueryParser::Contiguous_iteration_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    formula = std::make_unique<CEQL::ContiguousIterationFormula>(std::move(formula));
    return {};
  }
};

class WhereVisitor : public CEQLQueryParserBaseVisitor {
 private:
  // this formula is the corresponding parsed formula after parsing the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Formula> formula;

  FilterVisitor filter_visitor;

 public:
  CEQL::Where get_parsed_where() { return CEQL::Where(std::move(formula)); }

  virtual std::any visitCore_query(CEQLQueryParser::Core_queryContext* ctx) override {
    // Visiting Where clause will identify all streams.
    auto cel_formula_ctx = ctx->cel_formula();
    visit(cel_formula_ctx);
    return {};  // Only interested in stream names
  }

  virtual std::any visitEvent_type_cel_formula(
    CEQLQueryParser::Event_type_cel_formulaContext* ctx) override {
    if (ctx->s_event_name()->stream_name() == nullptr) {
      formula = std::make_unique<CEQL::EventTypeFormula>(
        ctx->s_event_name()->event_name()->getText());
    } else {
      formula = std::make_unique<CEQL::EventTypeFormula>(
        ctx->s_event_name()->stream_name()->getText(),
        ctx->s_event_name()->event_name()->getText());
    }
    return {};
  }

  virtual std::any
  visitAs_cel_formula(CEQLQueryParser::As_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    formula = std::make_unique<CEQL::AsFormula>(std::move(formula),
                                                ctx->event_name()->getText());
    return {};
  }

  virtual std::any visitNon_contiguous_iteration_cel_formula(
    CEQLQueryParser::Non_contiguous_iteration_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    formula = std::make_unique<CEQL::NonContiguousIterationFormula>(std::move(formula));
    return {};
  }

  virtual std::any visitNon_contiguous_sequencing_cel_formula(
    CEQLQueryParser::Non_contiguous_sequencing_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula()[0]);
    auto first_formula = std::move(formula);
    visit(ctx->cel_formula()[1]);
    formula = std::make_unique<CEQL::NonContiguousSequencingFormula>(std::move(
                                                                       first_formula),
                                                                     std::move(formula));
    return {};
  }

  virtual std::any visitContiguous_sequencing_cel_formula(
    CEQLQueryParser::Contiguous_sequencing_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula()[0]);
    auto first_formula = std::move(formula);
    visit(ctx->cel_formula()[1]);
    formula = std::make_unique<CEQL::ContiguousSequencingFormula>(std::move(first_formula),
                                                                  std::move(formula));
    return {};
  }

  virtual std::any
  visitOr_cel_formula(CEQLQueryParser::Or_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula()[0]);
    auto first_formula = std::move(formula);
    visit(ctx->cel_formula()[1]);
    formula = std::make_unique<CEQL::OrFormula>(std::move(first_formula),
                                                std::move(formula));
    return {};
  }

  virtual std::any
  visitFilter_cel_formula(CEQLQueryParser::Filter_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    filter_visitor.visit(ctx->filter());
    formula = std::make_unique<CEQL::FilterFormula>(std::move(formula),
                                                    filter_visitor.get_parsed_filter());
    return {};
  }

  virtual std::any visitContiguous_iteration_cel_formula(
    CEQLQueryParser::Contiguous_iteration_cel_formulaContext* ctx) override {
    visit(ctx->cel_formula());
    formula = std::make_unique<CEQL::ContiguousIterationFormula>(std::move(formula));
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
