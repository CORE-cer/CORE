#pragma once

#include <any>
#include <cstdint>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/value/attribute.hpp"
#include "core_server/internal/ceql/value/double_literal.hpp"
#include "core_server/internal/ceql/value/integer_literal.hpp"
#include "core_server/internal/ceql/value/operations/addition.hpp"
#include "core_server/internal/ceql/value/operations/division.hpp"
#include "core_server/internal/ceql/value/operations/modulo.hpp"
#include "core_server/internal/ceql/value/operations/multiplication.hpp"
#include "core_server/internal/ceql/value/operations/negation.hpp"
#include "core_server/internal/ceql/value/operations/subtraction.hpp"
#include "core_server/internal/ceql/value/sequence.hpp"
#include "core_server/internal/ceql/value/string_literal.hpp"
#include "core_server/internal/ceql/value/value.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"

namespace CORE::Internal::Parsing {
class ValueVisitor : public CEQLQueryParserBaseVisitor {
 private:
  // this formula is the corresponding parsed filter after parsing the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Value> value;
  std::set<std::string> attributes;

 public:
  std::unique_ptr<CEQL::Value> get_parsed_value() { return std::move(value); }

  std::set<std::string> get_attributes() {
    std::set<std::string> attributes_copy = attributes;
    attributes.clear();
    return attributes_copy;
  }

  virtual std::any visitInteger(CEQLQueryParser::IntegerContext* ctx) override {
    std::string integer_string = ctx->getText();
    value = std::make_unique<CEQL::IntegerLiteral>(std::stoll(integer_string));
    return {};
  }

  virtual std::any visitDouble(CEQLQueryParser::DoubleContext* ctx) override {
    std::string double_string = ctx->getText();
    value = std::make_unique<CEQL::DoubleLiteral>(std::stod(double_string));
    return {};
  }

  virtual std::any
  visitAttribute_math_expr(CEQLQueryParser::Attribute_math_exprContext* ctx) override {
    value = std::make_unique<CEQL::Attribute>(ctx->getText());
    attributes.insert(ctx->getText());
    return {};
  }

  virtual std::any
  visitUnary_math_expr(CEQLQueryParser::Unary_math_exprContext* ctx) override {
    visit(ctx->math_expr());
    if (ctx->MINUS()) {
      value = std::make_unique<CEQL::Negation>(std::move(value));
    }
    return {};
  }

  virtual std::any
  visitMul_math_expr(CEQLQueryParser::Mul_math_exprContext* ctx) override {
    visit(ctx->math_expr()[0]);
    std::unique_ptr<CEQL::Value> first_val = std::move(value);
    visit(ctx->math_expr()[1]);
    if (ctx->STAR()) {
      value = std::make_unique<CEQL::Multiplication>(std::move(first_val),
                                                     std::move(value));
    } else if (ctx->SLASH()) {
      value = std::make_unique<CEQL::Division>(std::move(first_val), std::move(value));
    } else {
      value = std::make_unique<CEQL::Modulo>(std::move(first_val), std::move(value));
    }
    return {};
  }

  virtual std::any
  visitSum_math_expr(CEQLQueryParser::Sum_math_exprContext* ctx) override {
    visit(ctx->math_expr()[0]);
    std::unique_ptr<CEQL::Value> first_val = std::move(value);
    visit(ctx->math_expr()[1]);
    if (ctx->PLUS()) {
      value = std::make_unique<CEQL::Addition>(std::move(first_val), std::move(value));
    } else {
      value = std::make_unique<CEQL::Subtraction>(std::move(first_val), std::move(value));
    }
    return {};
  }

  virtual std::any visitString(CEQLQueryParser::StringContext* ctx) override {
    std::string string_with_quotes = ctx->getText();
    std::string string_without_quotes = string_with_quotes.substr(1,
                                                                  string_with_quotes.size()
                                                                    - 2);
    value = std::make_unique<CEQL::StringLiteral>(string_without_quotes);
    return {};
  }

  virtual std::any
  visitAttribute_name(CEQLQueryParser::Attribute_nameContext* ctx) override {
    value = std::make_unique<CEQL::Attribute>(ctx->getText());
    attributes.insert(ctx->getText());
    return {};
  }

  virtual std::any
  visitInteger_range(CEQLQueryParser::Integer_rangeContext* ctx) override {
    int64_t first_int = std::stoll(ctx->integer()[0]->getText());
    int64_t second_int = std::stoll(ctx->integer()[1]->getText());
    value = std::make_unique<CEQL::Sequence>(std::make_unique<CEQL::IntegerLiteral>(
                                               first_int),
                                             std::make_unique<CEQL::IntegerLiteral>(
                                               second_int));
    return {};
  }

  virtual std::any visitDouble_range(CEQLQueryParser::Double_rangeContext* ctx) override {
    double first_double = std::stod(ctx->double_()[0]->getText());
    double second_double = std::stod(ctx->double_()[1]->getText());
    value = std::make_unique<CEQL::Sequence>(std::make_unique<CEQL::DoubleLiteral>(
                                               first_double),
                                             std::make_unique<CEQL::DoubleLiteral>(
                                               second_double));
    return {};
  }

  virtual std::any visitNumber_list(CEQLQueryParser::Number_listContext* ctx) override {
    std::vector<std::unique_ptr<CEQL::Value>> values;
    auto numbers = ctx->number();
    for (auto& num_ctx : numbers) {
      visit(num_ctx);
      values.push_back(std::move(value));
    }
    value = std::make_unique<CEQL::Sequence>(std::move(values));
    return {};
  }

  virtual std::any
  visitNumber_range_lower(CEQLQueryParser::Number_range_lowerContext* ctx) override {
    visit(ctx->number());
    value = std::make_unique<CEQL::Sequence>(std::move(value),
                                             CEQL::Sequence::LOWER_BOUND);
    return {};
  }

  virtual std::any
  visitNumber_range_upper(CEQLQueryParser::Number_range_upperContext* ctx) override {
    visit(ctx->number());
    value = std::make_unique<CEQL::Sequence>(std::move(value),
                                             CEQL::Sequence::UPPER_BOUND);
    return {};
  }

  virtual std::any visitString_seq(CEQLQueryParser::String_seqContext* ctx) override {
    std::vector<std::unique_ptr<CEQL::Value>> values;
    auto strings = ctx->string();
    for (auto& string_ctx : strings) {
      visit(string_ctx);
      values.push_back(std::move(value));
    }
    value = std::make_unique<CEQL::Sequence>(std::move(values));
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
