#pragma once
#include <memory>

#include "core_server/internal/ceql/query/where.hpp"
#include "core_server/internal/ceql/value/all_value_headers.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParserBaseVisitor.h"

namespace CORE::Internal::Parsing {
class ValueVisitor : public CEQLQueryParserBaseVisitor {
 private:
  // this formula is the corresponding parsed filter after parsing the
  // visitation to the ctx is finished.
  std::unique_ptr<CEQL::Value> value;

 public:
  std::unique_ptr<CEQL::Value> get_parsed_value() {
    return std::move(value);
  }

  virtual std::any
  visitInteger(CEQLQueryParser::IntegerContext* ctx) override {
    std::string integer_string = ctx->getText();
    value = std::make_unique<CEQL::IntegerLiteral>(
      std::stoll(integer_string));
    return {};
  }

  virtual std::any
  visitDouble(CEQLQueryParser::DoubleContext* ctx) override {
    std::string double_string = ctx->getText();
    value = std::make_unique<CEQL::DoubleLiteral>(std::stod(double_string));
    return {};
  }

  virtual std::any visitAttribute_math_expr(
    CEQLQueryParser::Attribute_math_exprContext* ctx) override {
    value = std::make_unique<CEQL::Attribute>(ctx->getText());
    return {};
  }

  virtual std::any visitUnary_math_expr(
    CEQLQueryParser::Unary_math_exprContext* ctx) override {
    visit(ctx->math_expr());
    if (ctx->MINUS()) {
      value = std::make_unique<CEQL::Negation>(std::move(value));
    }
    return {};
  }

  virtual std::any
  visitMul_math_expr(CEQLQueryParser::Mul_math_exprContext* ctx) override {
    visit(ctx->math_expr()[0]);
    std::unique_ptr<CEQL::Value> first_val = std::move(value);
    visit(ctx->math_expr()[1]);
    if (ctx->STAR()) {
      value = std::make_unique<CEQL::Multiplication>(std::move(first_val),
                                                     std::move(value));
    } else if (ctx->SLASH()) {
      value = std::make_unique<CEQL::Division>(std::move(first_val),
                                               std::move(value));
    } else {
      value = std::make_unique<CEQL::Modulo>(std::move(first_val),
                                             std::move(value));
    }
    return {};
  }

  virtual std::any
  visitSum_math_expr(CEQLQueryParser::Sum_math_exprContext* ctx) override {
    visit(ctx->math_expr()[0]);
    std::unique_ptr<CEQL::Value> first_val = std::move(value);
    visit(ctx->math_expr()[1]);
    if (ctx->PLUS()) {
      value = std::make_unique<CEQL::Addition>(std::move(first_val),
                                               std::move(value));
    } else {
      value = std::make_unique<CEQL::Subtraction>(std::move(first_val),
                                                  std::move(value));
    }
    return {};
  }

  virtual std::any
  visitString(CEQLQueryParser::StringContext* ctx) override {
    value = std::make_unique<CEQL::StringLiteral>(ctx->getText());
    return {};
  }

  virtual std::any
  visitRegexp(CEQLQueryParser::RegexpContext* ctx) override {
    value = std::make_unique<CEQL::RegexLiteral>(
      ctx->regexp_alternation()->getText());
    return {};
  }

  virtual std::any
  visitAttribute_name(CEQLQueryParser::Attribute_nameContext* ctx) override {
    value = std::make_unique<CEQL::Attribute>(ctx->getText());
    return {};
  }

  virtual std::any
  visitInteger_range(CEQLQueryParser::Integer_rangeContext* ctx) override {
    int64_t first_int = std::stoll(ctx->integer()[0]->getText());
    int64_t second_int = std::stoll(ctx->integer()[1]->getText());
    value = std::make_unique<CEQL::Sequence>(
      std::make_unique<CEQL::IntegerLiteral>(first_int),
      std::make_unique<CEQL::IntegerLiteral>(second_int));
    return {};
  }

  virtual std::any
  visitDouble_range(CEQLQueryParser::Double_rangeContext* ctx) override {
    double first_double = std::stod(ctx->double_()[0]->getText());
    double second_double = std::stod(ctx->double_()[1]->getText());
    value = std::make_unique<CEQL::Sequence>(
      std::make_unique<CEQL::DoubleLiteral>(first_double),
      std::make_unique<CEQL::DoubleLiteral>(second_double));
    return {};
  }

  virtual std::any
  visitNumber_list(CEQLQueryParser::Number_listContext* ctx) override {
    std::vector<std::unique_ptr<CEQL::Value>> values;
    auto numbers = ctx->number();
    for (auto& num_ctx : numbers) {
      visit(num_ctx);
      values.push_back(std::move(value));
    }
    value = std::make_unique<CEQL::Sequence>(std::move(values));
    return {};
  }

  virtual std::any visitNumber_range_lower(
    CEQLQueryParser::Number_range_lowerContext* ctx) override {
    visit(ctx->number());
    value = std::make_unique<CEQL::Sequence>(std::move(value),
                                             CEQL::Sequence::LOWER_BOUND);
    return {};
  }

  virtual std::any visitNumber_range_upper(
    CEQLQueryParser::Number_range_upperContext* ctx) override {
    visit(ctx->number());
    value = std::make_unique<CEQL::Sequence>(std::move(value),
                                             CEQL::Sequence::UPPER_BOUND);
    return {};
  }

  virtual std::any
  visitString_seq(CEQLQueryParser::String_seqContext* ctx) override {
    std::vector<std::unique_ptr<CEQL::Value>> values;
    auto strings = ctx->string();
    for (auto& string_ctx : strings) {
      visit(string_ctx);
      values.push_back(std::move(value));
    }
    value = std::make_unique<CEQL::Sequence>(std::move(values));
    return {};
  }
};
}  // namespace CORE::Internal::Parsing
