#pragma once

#include <any>
#include <cstddef>
#include <map>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/parsing/stream_declaration/autogenerated/StreamDeclarationParser.h"
#include "core_server/internal/parsing/stream_declaration/autogenerated/StreamDeclarationParserBaseVisitor.h"
#include "core_server/internal/parsing/stream_declaration/error_handling_utils.hpp"
#include "shared/datatypes/catalog/attribute_info.hpp"
#include "shared/datatypes/catalog/datatypes.hpp"
#include "shared/datatypes/parsing/event_info_parsed.hpp"

namespace CORE::Internal::Parsing::Declaration {
class EventVisitor : public StreamDeclarationParserBaseVisitor {
 private:
  std::string name;
  std::vector<Types::AttributeInfo> attributes_info;
  std::map<std::string, Types::ValueTypes> types_map =
    {{"int", Types::ValueTypes::INT64},
     {"string", Types::ValueTypes::STRING_VIEW},
     {"double", Types::ValueTypes::DOUBLE},
     {"boolean", Types::ValueTypes::BOOL}};

 public:
  Types::EventInfoParsed get_parsed_event() {
    return Types::EventInfoParsed(name, std::move(attributes_info));
  }

  virtual std::any
  visitEvent_declaration(StreamDeclarationParser::Event_declarationContext* ctx) override {
    auto event_name_ctx = ctx->event_name();
    name = event_name_ctx->getText();
    auto attribute_dec_list_ctx = ctx->attribute_dec_list();
    visit(attribute_dec_list_ctx);
    return {};
  }

  virtual std::any visitAttribute_dec_list(
    StreamDeclarationParser::Attribute_dec_listContext* ctx) override {
    auto attribute_declaration_ctx = ctx->attribute_declaration();
    for (size_t i = 0; i < attribute_declaration_ctx.size(); ++i) {
      visit(attribute_declaration_ctx[i]);
    }
    return {};
  }

  virtual std::any visitAttribute_declaration(
    StreamDeclarationParser::Attribute_declarationContext* ctx) override {
    std::string attribute_name = ctx->attribute_name()->getText();
    std::string datatype_string = ctx->datatype()->getText();
    Types::ValueTypes value_type = types_map[datatype_string];
    Types::AttributeInfo attribute(attribute_name, value_type);
    check_if_attribute_already_exists(attributes_info, attribute);
    attributes_info.push_back(attribute);
    return {};
  }
};
}  // namespace CORE::Internal::Parsing::Declaration
