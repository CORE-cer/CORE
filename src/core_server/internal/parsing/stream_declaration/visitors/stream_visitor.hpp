#pragma once

#include <any>
#include <cstddef>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/parsing/stream_declaration/autogenerated/StreamDeclarationParser.h"
#include "core_server/internal/parsing/stream_declaration/autogenerated/StreamDeclarationParserBaseVisitor.h"
#include "core_server/internal/parsing/stream_declaration/visitors/event_visitor.hpp"
#include "shared/datatypes/parsing/event_info_parsed.hpp"
#include "shared/datatypes/parsing/stream_info_parsed.hpp"
#include "core_server/internal/parsing/stream_declaration/error_handling_utils.hpp"

namespace CORE::Internal::Parsing::Declaration {
class StreamVisitorCatalog : public StreamDeclarationParserBaseVisitor {
 private:
  std::string name;
  std::vector<Types::EventInfoParsed> parsed_events_info;
  const std::set<std::string>& stream_names;

 public:
  StreamVisitorCatalog(const std::set<std::string>& stream_names): stream_names(stream_names) {}

  Types::StreamInfoParsed get_parsed_stream() {
    return Types::StreamInfoParsed(name, std::move(parsed_events_info));
  }

  virtual std::any
  visitCore_declaration(StreamDeclarationParser::Core_declarationContext* ctx) {
    auto stream_declaration_ctx = ctx->stream_declaration();
    visit(stream_declaration_ctx);
    return {};
  }

  virtual std::any
  visitStream_declaration(StreamDeclarationParser::Stream_declarationContext* ctx) {
    name = ctx->stream_name()->getText();
    check_if_stream_already_exists(stream_names, name);
    auto event_list_ctx = ctx->event_list();
    visit(event_list_ctx);
    return {};
  }

  virtual std::any visitEvent_list(StreamDeclarationParser::Event_listContext* ctx) {
    auto event_declaration_ctx = ctx->event_declaration();
    for (size_t i = 0; i < event_declaration_ctx.size(); ++i) {
      EventVisitor event_visitor;
      event_visitor.visit(event_declaration_ctx[i]);
      Types::EventInfoParsed event_info = event_visitor.get_parsed_event();
      check_if_event_already_exists(parsed_events_info, event_info);
      parsed_events_info.push_back(
        event_info);
    }
    return {};
  }
};

class StreamVisitor : public StreamDeclarationParserBaseVisitor {
 private:
  std::string name;
  std::vector<Types::EventInfoParsed> parsed_events_info;

 public:
  Types::StreamInfoParsed get_parsed_stream() {
    return Types::StreamInfoParsed(name, std::move(parsed_events_info));
  }

  virtual std::any
  visitCore_declaration(StreamDeclarationParser::Core_declarationContext* ctx) {
    auto stream_declaration_ctx = ctx->stream_declaration();
    visit(stream_declaration_ctx);
    return {};
  }

  virtual std::any
  visitStream_declaration(StreamDeclarationParser::Stream_declarationContext* ctx) {
    name = ctx->stream_name()->getText();
    auto event_list_ctx = ctx->event_list();
    visit(event_list_ctx);
    return {};
  }

  virtual std::any visitEvent_list(StreamDeclarationParser::Event_listContext* ctx) {
    auto event_declaration_ctx = ctx->event_declaration();
    for (size_t i = 0; i < event_declaration_ctx.size(); ++i) {
      EventVisitor event_visitor;
      event_visitor.visit(event_declaration_ctx[i]);
      parsed_events_info.push_back(
        Types::EventInfoParsed{event_visitor.get_parsed_event()});
    }
    return {};
  }
};
}  // namespace CORE::Internal::Parsing::Declaration
