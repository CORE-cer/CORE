#include "core_server/internal/evaluation/predicate_evaluator.hpp"

#include <ANTLRInputStream.h>
#include <CommonTokenStream.h>
#include <tree/ParseTree.h>

#include <catch2/catch_message.hpp>
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>
#include <cstdint>
#include <cstring>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/cel_formula/formula/projection_formula.hpp"
#include "core_server/internal/ceql/query/consume_by.hpp"
#include "core_server/internal/ceql/query/from.hpp"
#include "core_server/internal/ceql/query/limit.hpp"
#include "core_server/internal/ceql/query/partition_by.hpp"
#include "core_server/internal/ceql/query/query.hpp"
#include "core_server/internal/ceql/query/select.hpp"
#include "core_server/internal/ceql/query/within.hpp"
#include "core_server/internal/ceql/query_transformer/annotate_predicates_with_new_physical_predicates.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/coordination/query_catalog.hpp"
#include "core_server/internal/evaluation/physical_predicate/physical_predicate.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/from_visitor.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/where_visitor.hpp"
#include "shared/datatypes/catalog/attribute_info.hpp"
#include "shared/datatypes/catalog/datatypes.hpp"
#include "shared/datatypes/catalog/event_info.hpp"
#include "shared/datatypes/catalog/stream_info.hpp"
#include "shared/datatypes/event.hpp"
#include "shared/datatypes/eventWrapper.hpp"
#include "shared/datatypes/value.hpp"

namespace CORE::Internal::CEA::UnitTests {

std::vector<Types::AttributeInfo> attributes_of_event_type_1() {
  std::vector<Types::AttributeInfo> attributes_info;
  attributes_info.emplace_back("String", Types::ValueTypes::STRING_VIEW);
  attributes_info.emplace_back("Integer1", Types::ValueTypes::INT64);
  attributes_info.emplace_back("Integer2", Types::ValueTypes::INT64);
  attributes_info.emplace_back("Double1", Types::ValueTypes::DOUBLE);
  attributes_info.emplace_back("Double2", Types::ValueTypes::DOUBLE);
  return attributes_info;
}

Types::EventWrapper get_event_wrapper_event_type_1(std::string val1,
                                                   int64_t val2,
                                                   int64_t val3,
                                                   double val4,
                                                   double val5) {
  auto event = std::make_shared<Types::Event>(
    0,
    std::vector<std::shared_ptr<Types::Value>>{std::make_unique<Types::StringValue>(val1),
                                               std::make_unique<Types::IntValue>(val2),
                                               std::make_unique<Types::IntValue>(val3),
                                               std::make_unique<Types::DoubleValue>(val4),
                                               std::make_unique<Types::DoubleValue>(val5)});
  auto eventWrapper = Types::EventWrapper(std::move(event));
  return std::move(eventWrapper);
}

Types::EventWrapper
add_event_type_1(std::string val1, int64_t val2, int64_t val3, double val4, double val5) {
  return {std::move(get_event_wrapper_event_type_1(val1, val2, val3, val4, val5))};
}

std::vector<Types::AttributeInfo> attributes_of_event_type_2() {
  std::vector<Types::AttributeInfo> attributes_info;
  attributes_info.emplace_back("Integer1", Types::ValueTypes::INT64);
  attributes_info.emplace_back("Integer2", Types::ValueTypes::INT64);
  return attributes_info;
}

Types::EventWrapper get_event_wrapper_event_type_2(int64_t val1, int64_t val2) {
  auto event = std::make_shared<Types::Event>(1,
                                              std::vector<std::shared_ptr<Types::Value>>{
                                                std::make_unique<Types::IntValue>(val1),
                                                std::make_unique<Types::IntValue>(val2),
                                              });
  auto eventWrapper = Types::EventWrapper(std::move(event));
  return std::move(eventWrapper);
}

Types::EventWrapper add_event_type_2(int64_t val1, int64_t val2) {
  return {std::move(get_event_wrapper_event_type_2(val1, val2))};
}

std::string create_query(std::string filter_clause) {
  // clang-format off
  return "SELECT ALL * \n"
         "FROM S\n"
         "WHERE S>event1 as X; S>event2 as Y\n"
         "FILTER\n"
         + filter_clause + "\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

void process_catalog(Catalog& catalog) {
  Types::StreamInfo stream_info = catalog.add_stream_type(
    {"S",
     {{"event1", attributes_of_event_type_1()}, {"event2", attributes_of_event_type_2()}}});
  REQUIRE(stream_info.events_info[0].id == 0);
  REQUIRE(stream_info.events_info[1].id == 1);
}

CEQL::Query parse_query(std::string query,
                        Catalog& catalog) {  // Only parses where and from correctly
  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();

  Parsing::FromVisitor from_visitor(catalog);
  from_visitor.visit(tree);
  CEQL::From from = from_visitor.get_parsed_from();
  std::set<std::string>& streams = from.streams;
  std::map<std::string, std::vector<Types::EventInfo>>
    streams_events = Parsing::get_streams_events_map(catalog, streams);

  Parsing::WhereVisitor where_visitor(catalog, streams_events);
  where_visitor.visit(tree);
  std::unique_ptr<CEQL::ProjectionFormula> formula = std::make_unique<
    CEQL::ProjectionFormula>(std::set<std::string>{""},
                             std::set<std::pair<std::string, std::string>>{});

  // TODO: Partitionby, within and consume_by
  CEQL::Query parsed_query(
    CEQL::Select(CEQL::Select::Strategy::ALL, true, std::move(formula), {}, {}),
    CEQL::From({"S"}),
    std::move(where_visitor.get_parsed_where()),
    CEQL::PartitionBy(),
    CEQL::Within(),
    CEQL::ConsumeBy(),
    CEQL::Limit());
  return parsed_query;
}

std::vector<std::unique_ptr<PhysicalPredicate>>
get_predicates(CEQL::Query& query, QueryCatalog& query_catalog) {
  CEQL::AnnotatePredicatesWithNewPhysicalPredicates transformer(query_catalog);
  query = transformer(std::move(query));
  return std::move(transformer.physical_predicates);
}

TEST_CASE(
  "Predicate Evaluator creates the correct mpz_class for CompareMathExprs "
  "(bitset)",
  "[PredicateEvaluator]") {
  Catalog catalog;
  process_catalog(catalog);

  SECTION("StronglyTyped compare with constant") {
    CEQL::Query query = parse_query(create_query(
                                      "event1[Integer1 >= 20 AND Double1 >= 1.0] AND "
                                      "event2[Integer1 <= 30 OR Integer2 > 3]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00011);
  }

  SECTION("StronglyTyped compare with attribute mixed types math_exprs") {
    CEQL::Query query = parse_query(create_query("event1[Integer1 >= Double1 AND "
                                                 "Integer2 <= 1.0] AND "
                                                 "event2[Integer1 >= (Integer1 + 30) / "
                                                 "Integer2 AND 6 > Integer2]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b01011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b10101);
  }

  SECTION("WeaklyTyped simple comparison predicates") {
    CEQL::Query query = parse_query(create_query(
                                      "X[Integer1 >= 20 AND Double1 >= 1.0] AND "
                                      "event2[Integer1 <= 30 OR Integer2 > 3]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_2(20, 0);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b10101);
  }

  SECTION("WeaklyTyped complicated comparison predicates") {
    CEQL::Query query = parse_query(create_query("X[Integer1 >= 20 AND Integer2 >= "
                                                 "Integer1 * 2] AND "
                                                 "Y[Integer2 >= 30 OR Double1 > 3]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto predicates = get_predicates(query, query_catalog);
    INFO("Predicates with size: " + std::to_string(predicates.size()));
    INFO(predicates[0]->complete_info_string());
    INFO(predicates[1]->complete_info_string());
    INFO(predicates[2]->complete_info_string());
    INFO(predicates[3]->complete_info_string());
    auto evaluator = Evaluation::PredicateEvaluator(std::move(predicates));
    auto event = add_event_type_2(20, 40);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b11101);
  }

  SECTION("WeaklyTyped complicated comparison predicates no.2") {
    CEQL::Query query = parse_query(create_query("X[NOT((Integer1 - Integer2) * "
                                                 "Integer1 "
                                                 "/ (Double1 + 2) >= "
                                                 "20 AND NOT (Integer2 >= Integer1 * "
                                                 "2))] AND "
                                                 "X[Integer1 >= Double1 OR Integer1 == "
                                                 "Integer1] AND Y[Integer1 != "
                                                 "Integer2]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto predicates = get_predicates(query, query_catalog);
    INFO("Predicates with size: " + std::to_string(predicates.size()));
    INFO(predicates[0]->complete_info_string());
    INFO(predicates[1]->complete_info_string());
    INFO(predicates[2]->complete_info_string());
    INFO(predicates[3]->complete_info_string());
    INFO(predicates[4]->complete_info_string());
    auto evaluator = Evaluation::PredicateEvaluator(std::move(predicates));
    auto event = add_event_type_2(20, 40);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b111101);
  }

  SECTION("IN predicate works correctly") {
    // TODO
  }

  SECTION("StronglyTyped LIKE predicate matching") {
    CEQL::Query query = parse_query(create_query("event1[String LIKE '.*']"), catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b01011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00101);
  }

  SECTION("StronglyTyped LIKE predicate not matching") {
    CEQL::Query query = parse_query(create_query("event1[String LIKE 'another']"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00101);
  }

  SECTION("WeaklyTyped LIKE predicate matching") {
    CEQL::Query query = parse_query(create_query("X[String LIKE '.*']"), catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b01011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00101);
  }

  SECTION("WeaklyTyped LIKE predicate not matching") {
    CEQL::Query query = parse_query(create_query("X[String LIKE 'another']"), catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b00101);
  }

  SECTION("StronglyTyped IN RANGE (int, int) predicate complex true") {
    CEQL::Query query = parse_query(create_query("event1[Integer1 IN RANGE "
                                                 "(((Integer2*100)/120), "
                                                 "Integer1 * Integer2)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 292, 350, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b1011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("StronglyTyped IN RANGE (int, int) predicate complex false") {
    CEQL::Query query = parse_query(create_query("event1[Integer1 IN RANGE "
                                                 "(((Integer2*100)/120), "
                                                 "Integer1 * Integer2)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 150, 200, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("StronglyTyped IN RANGE (int, int) predicate trivially false") {
    CEQL::Query query = parse_query(create_query("event1[Integer1 IN RANGE (Integer1, "
                                                 "Integer2)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 19, 0.0, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("StronglyTyped IN RANGE predicate mixed types match") {
    CEQL::Query query = parse_query(create_query("event1[Integer1 IN RANGE (Integer1, "
                                                 "Double1)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 19, 20.5, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b1011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("StronglyTyped IN RANGE predicate mixed types not match") {
    CEQL::Query query = parse_query(create_query("event1[Integer1 IN RANGE (Integer1, "
                                                 "Double1)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 19, 19.8, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("WeaklyTyped IN RANGE predicate myxed types matching") {
    CEQL::Query query = parse_query(create_query("X[Integer1 IN RANGE (Integer1, "
                                                 "Double1)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 0, 25.5, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b1011);
    event = add_event_type_2(20, 5);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("WeaklyTyped IN RANGE predicate (int, int) matching") {
    CEQL::Query query = parse_query(create_query("X[Integer1 IN RANGE (Integer1, "
                                                 "Integer2)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 25, 25.5, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b1011);
    event = add_event_type_2(20, 21);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b1101);
  }

  SECTION("WeaklyTyped IN RANGE predicate (int, int) not matching") {
    CEQL::Query query = parse_query(create_query("X[Integer1 IN RANGE (Integer1, "
                                                 "Integer2)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 15, 25.5, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0011);
    event = add_event_type_2(20, 18);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }

  SECTION("WeaklyTyped IN RANGE predicate mixed types not matching") {
    CEQL::Query query = parse_query(create_query("X[Integer1 IN RANGE (Integer1, "
                                                 "Double1)]"),
                                    catalog);
    QueryCatalog query_catalog(catalog, query);
    auto evaluator = Evaluation::PredicateEvaluator(get_predicates(query, query_catalog));
    auto event = add_event_type_1("somestring", 20, 25, 18.5, 1.2);
    auto evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0011);
    event = add_event_type_2(20, 21);
    evaluation = evaluator(event);
    REQUIRE(evaluation == 0b0101);
  }
}
}  // namespace CORE::Internal::CEA::UnitTests
