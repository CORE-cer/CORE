#include "core_server/internal/ceql/cel_formula/filters/filter.hpp"

#include <ANTLRInputStream.h>
#include <CommonTokenStream.h>
#include <tree/ParseTree.h>

#include <catch2/catch_message.hpp>
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/cel_formula/formula/not_event_type_formula.hpp"
#include "core_server/internal/ceql/cel_formula/filters/and_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/atomic_filter.hpp"
#include "core_server/internal/ceql/cel_formula/filters/or_filter.hpp"
#include "core_server/internal/ceql/cel_formula/formula/filter_formula.hpp"
#include "core_server/internal/ceql/cel_formula/formula/formula.hpp"
#include "core_server/internal/ceql/cel_formula/predicate/inequality_predicate.hpp"
#include "core_server/internal/ceql/query/from.hpp"
#include "core_server/internal/ceql/query/where.hpp"
#include "core_server/internal/ceql/value/attribute.hpp"
#include "core_server/internal/ceql/value/integer_literal.hpp"
#include "core_server/internal/coordination/catalog.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/from_visitor.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/where_visitor.hpp"
#include "shared/datatypes/catalog/attribute_info.hpp"
#include "shared/datatypes/catalog/datatypes.hpp"
#include "shared/datatypes/catalog/event_info.hpp"
#include "shared/datatypes/catalog/stream_info.hpp"

namespace CORE::Internal::CEQL::UnitTests::FilterTests {

std::string create_query(std::string filter_clause) {
  // clang-format off
  return "SELECT ALL * \n"
         "FROM S, S1 ,S2\n"
         "WHERE S>T as t2; S>T as t3 \n"
         "--WHERE H+ OR H+\n"
         "FILTER\n"
         + filter_clause + "\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

std::string create_not_query(std::string not_clause) {
  // clang-format off
  return "SELECT ALL * \n"
         "FROM S3\n"
         "WHERE NOT ( " + not_clause + ") \n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

Where parse_where(std::string query) {
  Catalog catalog;
  Types::AttributeInfo temp("temp", Types::ValueTypes::INT64);
  Types::StreamInfo stream_info = catalog.add_stream_type(
    {"S", {{"H", {}}, {"T", {temp}}}});
  stream_info = catalog.add_stream_type({"S1", {{"H", {}}, {"t2", {temp}}}});
  stream_info = catalog.add_stream_type({"S2", {{"H", {}}, {"S", {}}}});
  stream_info = catalog.add_stream_type({"S3", {{"H", {}}, {"T", {temp}}}});

  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();

  Parsing::FromVisitor from_visitor(catalog);
  from_visitor.visit(tree);
  CEQL::From from = from_visitor.get_parsed_from();
  std::set<std::string>& streams = from.streams;
  std::map<std::string, std::vector<Types::EventInfo>>
    streams_events = Parsing::get_streams_events_map(catalog, streams);

  Parsing::WhereVisitor where_visitor(catalog, streams_events);
  where_visitor.visit(tree);
  return where_visitor.get_parsed_where();
}

std::unique_ptr<Formula> parse_formula(std::string query) {
  return std::move(parse_where(query).formula);
}

template <typename T>
std::unique_ptr<T> cast_to(std::unique_ptr<Formula> unknown) {
  std::unique_ptr<T> casted_optional(dynamic_cast<T*>(unknown.release()));
  return casted_optional;
}

template <typename T>
std::unique_ptr<T> cast_to(std::unique_ptr<Filter> unknown) {
  std::unique_ptr<T> casted_optional(dynamic_cast<T*>(unknown.release()));
  return casted_optional;
}

/***********************************/
/* Single functionality unit tests */
/***********************************/

/*************************/
/* Inequality Predicates */
/*************************/

std::unique_ptr<Filter> parse_filter(std::string query) {
  auto where = std::move(parse_where(query));
  auto formula = std::move(where.formula);
  REQUIRE(formula != nullptr);  // NOLINT
  auto filter_formula = cast_to<FilterFormula>(std::move(formula));
  REQUIRE(filter_formula != nullptr);  // NOLINT
  auto filter = std::move(filter_formula->filter);
  return std::move(filter);
}

using std::make_unique;

TEST_CASE("atomic filter works", "[Predicate, Inequality]") {
  auto query = create_query("t2[temp == 50]");
  std::unique_ptr<Filter> filter = parse_filter(query);
  auto expected_filter = make_unique<AtomicFilter>(
    "t2",
    make_unique<InequalityPredicate>(make_unique<Attribute>("temp"),
                                     InequalityPredicate::LogicalOperation::EQUALS,
                                     make_unique<IntegerLiteral>(50)));
  INFO("Expected: " + expected_filter->to_string());
  INFO("Got: " + filter->to_string());
  REQUIRE(filter->equals(expected_filter.get()));
}

TEST_CASE("atomic filter works with name and stream", "[Predicate, Inequality]") {
  auto query = create_query("S1>t2[temp == 50]");
  std::unique_ptr<Filter> filter = parse_filter(query);
  auto expected_filter = make_unique<AtomicFilter>(
    "S1",
    "t2",
    make_unique<InequalityPredicate>(make_unique<Attribute>("temp"),
                                     InequalityPredicate::LogicalOperation::EQUALS,
                                     make_unique<IntegerLiteral>(50)));
  INFO("Expected: " + expected_filter->to_string());
  INFO("Got: " + filter->to_string());
  REQUIRE(filter->equals(expected_filter.get()));
}

TEST_CASE("and filter works", "[Predicate, Inequality]") {
  auto query = create_query("t2[temp == 50] and t3[temp == 50]");
  std::unique_ptr<Filter> filter = parse_filter(query);
  auto expected_filter = make_unique<AndFilter>(
    make_unique<AtomicFilter>(
      "t2",
      make_unique<InequalityPredicate>(make_unique<Attribute>("temp"),
                                       InequalityPredicate::LogicalOperation::EQUALS,
                                       make_unique<IntegerLiteral>(50))),
    make_unique<AtomicFilter>(
      "t3",
      make_unique<InequalityPredicate>(make_unique<Attribute>("temp"),
                                       InequalityPredicate::LogicalOperation::EQUALS,
                                       make_unique<IntegerLiteral>(50))));
  INFO("Expected: " + expected_filter->to_string());
  INFO("Got: " + filter->to_string());
  REQUIRE(filter->equals(expected_filter.get()));
}

TEST_CASE("or filter works", "[Predicate, Inequality]") {
  auto query = create_query("t2[temp == 50] or t3[temp == 50]");
  std::unique_ptr<Filter> filter = parse_filter(query);
  auto expected_filter = make_unique<OrFilter>(
    make_unique<AtomicFilter>(
      "t2",
      make_unique<InequalityPredicate>(make_unique<Attribute>("temp"),
                                       InequalityPredicate::LogicalOperation::EQUALS,
                                       make_unique<IntegerLiteral>(50))),
    make_unique<AtomicFilter>(
      "t3",
      make_unique<InequalityPredicate>(make_unique<Attribute>("temp"),
                                       InequalityPredicate::LogicalOperation::EQUALS,
                                       make_unique<IntegerLiteral>(50))));
  INFO("Expected: " + expected_filter->to_string());
  INFO("Got: " + filter->to_string());
  REQUIRE(filter->equals(expected_filter.get()));
}

TEST_CASE("not event filter", "[Where, Not, FILTER]") {
  auto query = create_not_query("T FILTER T[temp>2]");
  // cout << formula->to_string();
  auto expected_formula = std::make_unique<CEQL::NotEventTypeFormula>(
    std::make_unique<CEQL::FilterFormula>(
      make_unique<EventTypeFormula>("T"),
        make_unique<AtomicFilter>("T",
        make_unique<InequalityPredicate>(
          make_unique<Attribute>("temp"),
          InequalityPredicate::LogicalOperation::GREATER,
          make_unique<IntegerLiteral>(2)
        )
      )
    )
  );
  // cout << expected_formula->to_string();
  auto formula = parse_formula(query);
  INFO("Expected: " + expected_formula->to_string());
  INFO("Got: " + formula->to_string());
  REQUIRE(formula->equals(expected_formula.get()));
}


  // auto expected_formula = std::make_unique<CEQL::NotEventTypeFormula>(
  //   std::make_unique<CEQL::AtomicFilter>(
  //     "T",
  //     make_unique<InequalityPredicate>(
  //       make_unique<Attribute>("Int"),
  //       InequalityPredicate::LogicalOperation::LESS_EQUALS,
  //       make_unique<IntegerLiteral>(2)
  //     )
  //   )
  // );

// TEST_CASE("not > physical_predicate works", "[Predicate]") {
//   auto query = create_query("t2[not temp > 50]");
//   std::unique_ptr<Predicate> predicate = parse_predicate(query);
//   auto expected_predicate = make_unique<InequalityPredicate>(
//     make_unique<Attribute>("temp"),
//     InequalityPredicate::LogicalOperation::LESS_EQUALS,
//     make_unique<IntegerLiteral>(50));
//   INFO("Expected: " + expected_predicate->to_string());
//   INFO("Got: " + predicate->to_string());
//   REQUIRE(predicate->equals(expected_predicate.get()));
// }
}  // namespace CORE::Internal::CEQL::UnitTests::FilterTests
