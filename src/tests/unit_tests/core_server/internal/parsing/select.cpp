#include "core_server/internal/ceql/query/select.hpp"

#include <ANTLRInputStream.h>
#include <CommonTokenStream.h>
#include <tree/ParseTree.h>

#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>
#include <set>
#include <string>
#include <utility>

#include "core_server/internal/ceql/cel_formula/formula/projection_formula.hpp"
#include "core_server/internal/ceql/query/query.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/from_visitor.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/select_visitor.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/where_visitor.hpp"

namespace CORE::Internal::CEQL::UnitTests {

std::string create_select_query(std::string strategy, std::string variable_names) {
  // clang-format off
  return "SELECT " + strategy + " " + variable_names + "\n"
         "FROM S, S2\n"
         "WHERE ( S>T ; H + ; T AS t2 ) AS all_events\n"
         "--WHERE H+ OR H+\n"
         "FILTER\n"
         "    all_events[id NOT IN { 123, 125 }]\n"
         "    AND\n"
         "    ( t2[temp > 50 or temp < 20] OR H[income > 2 * cost] )\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

Select parse_select(std::string query) {
  Catalog catalog;
  Types::StreamInfo stream_info = catalog.add_stream_type(
    {"S", {{"H", {}}, {"T", {}}, {"A", {}}, {"B", {}}}});
  stream_info = catalog.add_stream_type({"S2", {{"H", {}}, {"S", {}}, {"C", {}}}});

  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();

  Parsing::FromVisitor from_visitor(catalog);
  from_visitor.visit(tree);
  CEQL::From from = from_visitor.get_parsed_from();
  std::set<std::string>& streams = from.streams;
  std::map<std::string, std::vector<Types::EventInfo>>
    streams_events = Parsing::get_streams_events_map(catalog, streams);

  Parsing::WhereVisitor where_visitor(catalog, streams_events);
  where_visitor.visit(tree);
  CEQL::Where where = where_visitor.get_parsed_where();

  std::vector<std::string> as_events = where_visitor.get_as_events();
  Parsing::SelectVisitor select_visitor(catalog, streams_events, as_events);
  select_visitor.visit(tree);
  return select_visitor.get_parsed_select();
}

TEST_CASE("Select captures strategy correctly", "[Select, Strategy]") {
  // clang-format off
  REQUIRE(parse_select(create_select_query("ALL", "*")).strategy == Select::Strategy::ALL);
  REQUIRE(parse_select(create_select_query("ANY", "*")).strategy == Select::Strategy::ANY);
  REQUIRE(parse_select(create_select_query("LAST", "*")).strategy == Select::Strategy::LAST);
  REQUIRE(parse_select(create_select_query("MAX", "*")).strategy == Select::Strategy::MAX);
  REQUIRE(parse_select(create_select_query("NEXT", "*")).strategy == Select::Strategy::NEXT);
  REQUIRE(parse_select(create_select_query("STRICT", "*")).strategy == Select::Strategy::STRICT);
  REQUIRE(parse_select(create_select_query("", "*")).strategy == Select::Strategy::DEFAULT);
  // clang-format on
}

TEST_CASE("Select captures star correctly", "[Select, list_of_variables]") {
  REQUIRE(parse_select(create_select_query("ALL", "*")).is_star);
  REQUIRE(!parse_select(create_select_query("ALL", "T")).is_star);
}

TEST_CASE("Select captures list_of_variables correctly", "[Select, list_of_variables]") {
  ProjectionFormula* formula;
  std::set<std::string> vars;
  std::set<std::pair<std::string, std::string>> streams_events;
  bool condition;

  Select select = parse_select(create_select_query("", "A"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.contains("A") && vars.size() == 1 && streams_events.size() == 0;
  REQUIRE(condition);

  select = parse_select(create_select_query("", "A, B"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.contains("A") && vars.contains("B") && vars.size() == 2
              && streams_events.size() == 0;
  REQUIRE(condition);

  select = parse_select(create_select_query("", "A, B, C"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.contains("A") && vars.contains("B") && vars.contains("C")
              && vars.size() == 3 && streams_events.size() == 0;

  REQUIRE(condition);

  select = parse_select(create_select_query("", "*"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.size() == 0 && streams_events.size() == 0;
  REQUIRE(condition);

  select = parse_select(create_select_query("", "A, A"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.contains("A") && vars.size() == 1 && streams_events.size() == 0;
  REQUIRE(condition);
}

TEST_CASE("Select captures list_of_variables with streams correctly",
          "[Select, list_of_variables]") {
  ProjectionFormula* formula;
  std::set<std::string> vars;
  std::set<std::pair<std::string, std::string>> streams_events;
  bool condition;

  Select select = parse_select(create_select_query("", "S>A"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.size() == 0 && streams_events.contains({"S", "A"})
              && streams_events.size() == 1;
  REQUIRE(condition);

  select = parse_select(create_select_query("", "A, S>B"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.contains("A") && vars.size() == 1
              && streams_events.contains({"S", "B"}) && streams_events.size() == 1;

  REQUIRE(condition);

  select = parse_select(create_select_query("", "A, B, S2>C"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.contains("A") && vars.contains("B") && vars.size() == 2
              && streams_events.contains({"S2", "C"}) && streams_events.size() == 1;

  REQUIRE(condition);

  select = parse_select(create_select_query("", "S>A, S>A"));
  formula = static_cast<ProjectionFormula*>(select.formula.get());
  vars = formula->variables;
  streams_events = formula->streams_events;
  condition = vars.size() == 0 && streams_events.contains({"S", "A"})
              && streams_events.size() == 1;
  REQUIRE(condition);
}
}  // namespace CORE::Internal::CEQL::UnitTests
