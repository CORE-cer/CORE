#include "core_server/internal/ceql/cel_formula/formula/visitors/get_all_atomic_filters.hpp"

#include <ANTLRInputStream.h>
#include <CommonTokenStream.h>
#include <tree/ParseTree.h>

#include <catch2/catch_message.hpp>
#include <catch2/catch_test_macros.hpp>
#include <catch2/matchers/catch_matchers_vector.hpp>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "core_server/internal/ceql/cel_formula/formula/formula.hpp"
#include "core_server/internal/ceql/cel_formula/predicate/and_predicate.hpp"
#include "core_server/internal/ceql/cel_formula/predicate/inequality_predicate.hpp"
#include "core_server/internal/ceql/cel_formula/predicate/predicate.hpp"
#include "core_server/internal/ceql/query/where.hpp"
#include "core_server/internal/ceql/value/attribute.hpp"
#include "core_server/internal/ceql/value/integer_literal.hpp"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryLexer.h"
#include "core_server/internal/parsing/ceql_query/autogenerated/CEQLQueryParser.h"
#include "core_server/internal/parsing/ceql_query/error_handling_utils.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/from_visitor.hpp"
#include "core_server/internal/parsing/ceql_query/visitors/where_visitor.hpp"

namespace CORE::Internal::CEQL::UnitTests {

std::string create_query(std::string filter_clause) {
  // clang-format off
  return "SELECT ALL * \n"
         "FROM S, S2\n"
         "WHERE S>T \n"
         "--WHERE H+ OR H+\n"
         "FILTER\n"
         + filter_clause + "\n"
         "WITHIN 4 EVENTS\n";
  // clang-format on
}

Where parse_where(std::string query) {
  Catalog catalog;
  Types::StreamInfo stream_info = catalog.add_stream_type({"S", {{"H", {}}, {"T", {}}}});
  stream_info = catalog.add_stream_type({"S2", {{"H", {}}, {"S", {}}}});

  antlr4::ANTLRInputStream input(query);
  CEQLQueryLexer lexer(&input);
  antlr4::CommonTokenStream tokens(&lexer);
  CEQLQueryParser parser(&tokens);
  antlr4::tree::ParseTree* tree = parser.parse();

  Parsing::FromVisitor from_visitor(catalog);
  from_visitor.visit(tree);
  CEQL::From from = from_visitor.get_parsed_from();
  std::set<std::string>& streams = from.streams;
  std::map<std::string, std::vector<Types::EventInfo>>
    streams_events = Parsing::get_streams_events_map(catalog, streams);

  Parsing::WhereVisitor where_visitor(catalog, streams_events);
  where_visitor.visit(tree);
  return where_visitor.get_parsed_where();
}

std::unique_ptr<Formula> parse_formula(std::string query) {
  return std::move(parse_where(query).formula);
}

std::unique_ptr<Predicate> create_example_and_predicate() {
  std::vector<std::unique_ptr<Predicate>> predicates;
  predicates.push_back(
    std::make_unique<InequalityPredicate>(std::make_unique<Attribute>("temp"),
                                          InequalityPredicate::LogicalOperation::NOT_EQUALS,
                                          std::make_unique<IntegerLiteral>(50)));
  predicates.push_back(
    std::make_unique<InequalityPredicate>(std::make_unique<Attribute>("temp"),
                                          InequalityPredicate::LogicalOperation::GREATER,
                                          std::make_unique<IntegerLiteral>(30)));
  return std::make_unique<AndPredicate>(std::move(predicates));
}

TEST_CASE("get_all_ceql_predicates gets all predicates", "[ValueToMathExpr]") {
  GetAllAtomicFilters visitor;
  auto formula = parse_formula(
    create_query("t2[temp == 50] or (t3[temp != 50 and temp > 30] AND t1[temp < 3])"));
  formula->accept_visitor(visitor);
  std::vector<std::unique_ptr<Predicate>> expected_predicates;
  expected_predicates.push_back(
    std::make_unique<InequalityPredicate>(std::make_unique<Attribute>("temp"),
                                          InequalityPredicate::LogicalOperation::EQUALS,
                                          std::make_unique<IntegerLiteral>(50)));
  expected_predicates.push_back(create_example_and_predicate());
  expected_predicates.push_back(
    std::make_unique<InequalityPredicate>(std::make_unique<Attribute>("temp"),
                                          InequalityPredicate::LogicalOperation::LESS,
                                          std::make_unique<IntegerLiteral>(3)));
  INFO("Original Formula: " + formula->to_string());
  REQUIRE(visitor.atomic_filters.size() == 3);
  INFO(
    "Note that if this test fails due to order, then the test case "
    "should be fixed (any order should be admissible)");
  for (int i = 0; i < 3; i++) {
    INFO("Expected: " + expected_predicates[i]->to_string()
         + " Got: " + visitor.atomic_filters[i]->predicate->to_string());
    REQUIRE(expected_predicates[i]->equals(visitor.atomic_filters[i]->predicate.get()));
  }
}
}  // namespace CORE::Internal::CEQL::UnitTests
